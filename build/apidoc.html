<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/TypeStrong/grunt-ts"

    >grunt-ts (v5.5.1)</a>
</h1>
<h4>Compile and manage your TypeScript project</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts">module grunt-ts</a><ol>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>amdLoader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>cacheUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>compile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>html2ts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>optionsResolver</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>reference</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>templateCache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>transformers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>tsconfig</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>visualStudioOptionsResolver</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.amdLoader">module grunt-ts.amdLoader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.amdLoader.getReferencesInOrder">
            function <span class="apidocSignatureSpan">grunt-ts.amdLoader.</span>getReferencesInOrder
            <span class="apidocSignatureSpan">(referenceFile, referencePath, generatedFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.amdLoader.updateAmdLoader">
            function <span class="apidocSignatureSpan">grunt-ts.amdLoader.</span>updateAmdLoader
            <span class="apidocSignatureSpan">(referenceFile, files, loaderFile, loaderPath, outDir, newLine)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.cacheUtils">module grunt-ts.cacheUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.anyNewerThan">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>anyNewerThan
            <span class="apidocSignatureSpan">(paths, time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.clearCache">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>clearCache
            <span class="apidocSignatureSpan">(targetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.compileSuccessfull">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>compileSuccessfull
            <span class="apidocSignatureSpan">(paths, targetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.filterPathsByTime">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>filterPathsByTime
            <span class="apidocSignatureSpan">(paths, targetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.getNewFilesForTarget">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>getNewFilesForTarget
            <span class="apidocSignatureSpan">(paths, targetName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>cacheDir</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.compile">module grunt-ts.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.compile.compileAllFiles">
            function <span class="apidocSignatureSpan">grunt-ts.compile.</span>compileAllFiles
            <span class="apidocSignatureSpan">(options, compilationInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.compile.compileResultMeansFastCacheShouldBeRefreshed">
            function <span class="apidocSignatureSpan">grunt-ts.compile.</span>compileResultMeansFastCacheShouldBeRefreshed
            <span class="apidocSignatureSpan">(options, result)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.compile.</span>grunt</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.html2ts">module grunt-ts.html2ts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.html2ts.compileHTML">
            function <span class="apidocSignatureSpan">grunt-ts.html2ts.</span>compileHTML
            <span class="apidocSignatureSpan">(filename, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.optionsResolver">module grunt-ts.optionsResolver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.optionsResolver.resolveAsync">
            function <span class="apidocSignatureSpan">grunt-ts.optionsResolver.</span>resolveAsync
            <span class="apidocSignatureSpan">(rawTaskOptions, rawTargetOptions, targetName, resolvedFiles, theTemplateProcessor, theGlobExpander)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.reference">module grunt-ts.reference</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.reference.updateReferenceFile">
            function <span class="apidocSignatureSpan">grunt-ts.reference.</span>updateReferenceFile
            <span class="apidocSignatureSpan">(files, generatedFiles, referenceFile, referencePath, eol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.templateCache">module grunt-ts.templateCache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.templateCache.generateTemplateCache">
            function <span class="apidocSignatureSpan">grunt-ts.templateCache.</span>generateTemplateCache
            <span class="apidocSignatureSpan">(src, dest, basePath, eol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.transformers">module grunt-ts.transformers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.transformers.transformFiles">
            function <span class="apidocSignatureSpan">grunt-ts.transformers.</span>transformFiles
            <span class="apidocSignatureSpan">(changedFiles, targetFiles, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.tsconfig">module grunt-ts.tsconfig</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.tsconfig.resolveAsync">
            function <span class="apidocSignatureSpan">grunt-ts.tsconfig.</span>resolveAsync
            <span class="apidocSignatureSpan">(applyTo, taskOptions, targetOptions, theTemplateProcessor, theGlobExpander)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.utils">module grunt-ts.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.asyncSeries">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>asyncSeries
            <span class="apidocSignatureSpan">(items, callPerItem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.copyFile">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>copyFile
            <span class="apidocSignatureSpan">(srcFile, destFile, callback, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.enclosePathInQuotesIfRequired">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>enclosePathInQuotesIfRequired
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.endsWith">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>endsWith
            <span class="apidocSignatureSpan">(str, suffix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.findCommonPath">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>findCommonPath
            <span class="apidocSignatureSpan">(paths, pathSeperator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.firstElementWithValue">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>firstElementWithValue
            <span class="apidocSignatureSpan">(elements, defaultResult)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.format">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>format
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getDirs">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getDirs
            <span class="apidocSignatureSpan">(dirPath, exclude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getFiles">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getFiles
            <span class="apidocSignatureSpan">(dirPath, exclude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getOrGetFirst">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getOrGetFirst
            <span class="apidocSignatureSpan">(getFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getRandomHex">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getRandomHex
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getTempFile">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getTempFile
            <span class="apidocSignatureSpan">(prefix, dir, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.hasValue">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>hasValue
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.insertArrayAt">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>insertArrayAt
            <span class="apidocSignatureSpan">(array, index, arrayToInsert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.isJavaScriptFile">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>isJavaScriptFile
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.makeRelativePath">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>makeRelativePath
            <span class="apidocSignatureSpan">(folderpath, filename, forceRelative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.newLineActualAsParameter">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineActualAsParameter
            <span class="apidocSignatureSpan">(actualNewLineChars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.newLineIsRedundantForTsc">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineIsRedundantForTsc
            <span class="apidocSignatureSpan">(newLineParameter, operatingSystem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.newLineParameterAsActual">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineParameterAsActual
            <span class="apidocSignatureSpan">(parameterNewLineChars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.readAndParseJSONFromFileSync">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>readAndParseJSONFromFileSync
            <span class="apidocSignatureSpan">(fileName, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.shouldCompile">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>shouldCompile
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.shouldPassThrough">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>shouldPassThrough
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.stripQuotesIfQuoted">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>stripQuotesIfQuoted
            <span class="apidocSignatureSpan">(possiblyQuotedString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.timeIt">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>timeIt
            <span class="apidocSignatureSpan">(makeIt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.utils.</span>grunt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">grunt-ts.utils.</span>eol</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.visualStudioOptionsResolver">module grunt-ts.visualStudioOptionsResolver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.visualStudioOptionsResolver.resolveVSOptionsAsync">
            function <span class="apidocSignatureSpan">grunt-ts.visualStudioOptionsResolver.</span>resolveVSOptionsAsync
            <span class="apidocSignatureSpan">(applyTo, taskOptions, targetOptions, theTemplateProcessor)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts" id="apidoc.module.grunt-ts">module grunt-ts</a></h1>























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.amdLoader" id="apidoc.module.grunt-ts.amdLoader">module grunt-ts.amdLoader</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.amdLoader.getReferencesInOrder" id="apidoc.element.grunt-ts.amdLoader.getReferencesInOrder">
        function <span class="apidocSignatureSpan">grunt-ts.amdLoader.</span>getReferencesInOrder
        <span class="apidocSignatureSpan">(referenceFile, referencePath, generatedFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getReferencesInOrder(referenceFile, referencePath, generatedFiles) {
    var toreturn = {
        all: [],
        before: [],
        generated: [],
        unordered: [],
        after: []
    };
    var sortedGeneratedFiles = _.sortBy(generatedFiles);
    function isGeneratedFile(filename) {
        return _.indexOf(sortedGeneratedFiles, filename, true) !== -1;
    }
    // When reading
    var referenceMatch = /\/\/\/ &#x3c;reference path=\&#x22;(.*?)\&#x22;/;
    // When writing
    var referenceIntro = &#x27;/// &#x3c;reference path=&#x22;&#x27;;
    // var referenceEnd = &#x27;&#x22; /&#x3e;&#x27;;
    // The section of unordered files
    var ourSignatureStart = &#x27;//grunt-start&#x27;;
    var ourSignatureEnd = &#x27;//grunt-end&#x27;;
    var lines = fs.readFileSync(referenceFile).toString().split(&#x27;\n&#x27;);
    // Which of the three sections we are in
    var loopState = 0 /* before */;
    for (var i = 0; i &#x3c; lines.length; i++) {
        var line = _str.trim(lines[i]);
        if (_str.include(line, ourSignatureStart)) {
            // Wait for the end signature:
            loopState = 1 /* unordered */;
        }
        if (_str.include(line, ourSignatureEnd)) {
            loopState = 2 /* after */;
        }
        // Fetch the existing reference&#x27;s filename if any:
        if (_str.include(line, referenceIntro)) {
            var match = line.match(referenceMatch);
            var filename = match[1];
            switch (loopState) {
                case 0 /* before */:
                    toreturn.before.push(filename);
                    break;
                case 1 /* unordered */:
                    if (isGeneratedFile(filename)) {
                        toreturn.generated.push(filename);
                    }
                    else {
                        toreturn.unordered.push(filename);
                    }
                    break;
                case 2 /* after */:
                    toreturn.after.push(filename);
                    break;
            }
        }
    }
    // Fix the references to be absolute:
    toreturn.before = _.map(toreturn.before, function (relativePath) { return path.resolve(referencePath, relativePath); });
    toreturn.generated = _.map(toreturn.generated, function (relativePath) { return path.resolve(referencePath, relativePath); });
    toreturn.unordered = _.map(toreturn.unordered, function (relativePath) { return path.resolve(referencePath, relativePath); });
    toreturn.after = _.map(toreturn.after, function (relativePath) { return path.resolve(referencePath, relativePath); });
    toreturn.all = Array.prototype.concat.call([], toreturn.before, toreturn.generated, toreturn.unordered, toreturn.after);
    return toreturn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (result.it === true) {
        grunt.log.writeln((&#x27;Updated reference file (&#x27; + result.time + &#x27;ms).&#x27;).green);
    }
}
///// AMD loader
// Create the amdLoader if specified
if (!!amdloaderPath) {
    var referenceOrder = amdLoaderModule.<span class="apidocCodeKeywordSpan">getReferencesInOrder</span>(referenceFile, referencePath
, generatedFiles);
    amdLoaderModule.updateAmdLoader(referenceFile, referenceOrder, amdloaderFile, amdloaderPath, currentFiles.outDir);
}
// Transform files as needed. Currently all of this logic in is one module
transformers.transformFiles(filesToCompile /*TODO: only unchanged files*/, filesToCompile, options);
currentFiles.src = filesToCompile;
// Return promise to compliation
if (utils.shouldCompile(options)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.amdLoader.updateAmdLoader" id="apidoc.element.grunt-ts.amdLoader.updateAmdLoader">
        function <span class="apidocSignatureSpan">grunt-ts.amdLoader.</span>updateAmdLoader
        <span class="apidocSignatureSpan">(referenceFile, files, loaderFile, loaderPath, outDir, newLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAmdLoader(referenceFile, files, loaderFile, loaderPath, outDir, newLine) {
    if (newLine === void 0) { newLine = utils.eol; }
    var commonPath;
    var makeRelativeToOutDir = function (files) {
        files = _.map(files, function (file) {
            // Remove common path and replace with absolute outDir
            file = file.replace(commonPath, outDir);
            // remove extension &#x27;.ts&#x27; / &#x27;.tsx&#x27;:
            file = file.substr(0, file.lastIndexOf(&#x27;.&#x27;));
            // Make relative to amd loader
            file = utils.makeRelativePath(loaderPath, file);
            // Prepend &#x22;./&#x22; to prevent &#x22;basePath&#x22; requirejs setting from interferring:
            file = &#x27;./&#x27; + file;
            return file;
        });
        return files;
    };
    // Read the original file if it exists
    if (fs.existsSync(referenceFile)) {
        grunt.log.verbose.writeln(&#x27;Generating amdloader from reference file &#x27; + referenceFile);
        // Filter.d.ts,
        if (files.all.length &#x3e; 0) {
            grunt.log.verbose.writeln(&#x27;Files: &#x27; + files.all.map(function (f) { return f.cyan; }).join(&#x27;, &#x27;));
        }
        else {
            grunt.warn(&#x27;No files in reference file: &#x27; + referenceFile);
        }
        if (files.before.length &#x3e; 0) {
            files.before = _.filter(files.before, function (file) { return !utils.endsWith(file, &#x27;.d.ts&#x27;); });
            grunt.log.verbose.writeln(&#x27;Before: &#x27; + files.before.map(function (f) { return f.cyan; }).join(&#x27;, &#x27;));
        }
        if (files.generated.length &#x3e; 0) {
            files.generated = _.filter(files.generated, function (file) { return !utils.endsWith(file, &#x27;.d.ts&#x27;); });
            grunt.log.verbose.writeln(&#x27;Generated: &#x27; + files.generated.map(function (f) { return f.cyan; }).join(&#x27;, &#x27;));
        }
        if (files.unordered.length &#x3e; 0) {
            files.unordered = _.filter(files.unordered, function (file) { return !utils.endsWith(file, &#x27;.d.ts&#x27;); });
            grunt.log.verbose.writeln(&#x27;Unordered: &#x27; + files.unordered.map(function (f) { return f.cyan; }).join(&#x27;, &#x27;));
        }
        if (files.after.length &#x3e; 0) {
            files.after = _.filter(files.after, function (file) { return !utils.endsWith(file, &#x27;.d.ts&#x27;); });
            grunt.log.verbose.writeln(&#x27;After: &#x27; + files.after.map(function (f) { return f.cyan; }).join(&#x27;, &#x27;));
        }
        // If target has outDir we need to make adjust the path
        // c:/somefolder/ts/a , c:/somefolder/ts/inside/b  + c:/somefolder/build/js =&#x3e; c:/somefolder/build/js/a , c:/somefolder/
build/js/inside/b
        // Logic:
        //     find the common structure in the source files ,and remove it
        //          Finally: outDir path + remainder section
        if (outDir) {
            // Find common path
            commonPath = utils.findCommonPath(files.before.concat(files.generated.concat(files.unordered.concat(files.after))),
pathSeperator);
            grunt.log.verbose.writeln(&#x27;Found common path: &#x27; + commonPath);
            // Make sure outDir is absolute:
            outDir = path.resolve(outDir);
            grunt.log.verbose.writeln(&#x27;Using outDir: &#x27; + outDir);
            grunt.log.verbose.writeln(&#x27;Making files relative to outDir...&#x27;);
            files.before = makeRelativeToOutDir(files.before);
            files.generated = makeRelativeToOutDir(files.generated);
            files.unordered = makeRelativeToOutDir(files.unordered);
            files.after = makeRelativeToOutDir(files.after);
            var mainTemplate = _.template(&#x27;define(function (require) { &#x27;
                + newLine + &#x27;&#x3c;%= body %&#x3e;&#x27;
                + newLine + &#x27;});&#x27;);
            // The order in the before and after files is important
            var singleRequireTemplate = _.template(&#x27;\t require([&#x3c;%= filename %&#x3e;],function (){&#x27;
                + newLine + &#x27;&#x3c;%= subitem %&#x3e;&#x27;
                + newLine + &#x27;\t });&#x27;);
            // initial sub item
            var subitem = &#x27;&#x27;;
            // Write out a binary file:
            var binaryTemplate = _.template ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        grunt.log.writeln((&#x27;Updated reference file (&#x27; + result.time + &#x27;ms).&#x27;).green);
    }
}
///// AMD loader
// Create the amdLoader if specified
if (!!amdloaderPath) {
    var referenceOrder = amdLoaderModule.getReferencesInOrder(referenceFile, referencePath, generatedFiles);
    amdLoaderModule.<span class="apidocCodeKeywordSpan">updateAmdLoader</span>(referenceFile, referenceOrder, amdloaderFile, amdloaderPath
, currentFiles.outDir);
}
// Transform files as needed. Currently all of this logic in is one module
transformers.transformFiles(filesToCompile /*TODO: only unchanged files*/, filesToCompile, options);
currentFiles.src = filesToCompile;
// Return promise to compliation
if (utils.shouldCompile(options)) {
    if (filesToCompile.length &#x3e; 0 || options.testExecute || utils.shouldPassThrough(options)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.cacheUtils" id="apidoc.module.grunt-ts.cacheUtils">module grunt-ts.cacheUtils</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.anyNewerThan" id="apidoc.element.grunt-ts.cacheUtils.anyNewerThan">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>anyNewerThan
        <span class="apidocSignatureSpan">(paths, time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function anyNewerThan(paths, time) {
    return getFilesNewerThan(paths, time).length &#x3e; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.clearCache" id="apidoc.element.grunt-ts.cacheUtils.clearCache">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>clearCache
        <span class="apidocSignatureSpan">(targetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearCache(targetName) {
    var cacheDirForTarget = path.join(exports.cacheDir, targetName);
    try {
        if (fs.existsSync(cacheDirForTarget)) {
            rimraf.sync(cacheDirForTarget);
            grunt.log.writeln((&#x27;Cleared fast compile cache for target: &#x27; + targetName).cyan);
        }
    }
    catch (ex) {
        grunt.log.writeln((&#x27;Failed to clear compile cache for target: &#x27; + targetName).red);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
return files;
}
function resetChangedFiles(files, targetName) {
cache.compileSuccessfull(files, targetName);
}
function clearCache(targetName) {
cache.<span class="apidocCodeKeywordSpan">clearCache</span>(targetName);
cacheClearedOnce[targetName] = true;
}
/////////////////////////////////////////////////////////////////////
// tsc handling
////////////////////////////////////////////////////////////////////
function resolveTypeScriptBinPath() {
var ownRoot = path.resolve(path.dirname((module).filename), &#x27;../..&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.compileSuccessfull" id="apidoc.element.grunt-ts.cacheUtils.compileSuccessfull">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>compileSuccessfull
        <span class="apidocSignatureSpan">(paths, targetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileSuccessfull(paths, targetName) {
    // update timestamp
    grunt.file.write(getStampPath(targetName), &#x27;&#x27;);
    // update filehash
    updateHashes(paths, targetName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    files = cache.getNewFilesForTarget(files, targetName);
    _.forEach(files, function (file) {
        exports.grunt.log.writeln((&#x27;### Fast Compile &#x3e;&#x3e;&#x27; + file).cyan);
    });
    return files;
}
function resetChangedFiles(files, targetName) {
    cache.<span class="apidocCodeKeywordSpan">compileSuccessfull</span>(files, targetName);
}
function clearCache(targetName) {
    cache.clearCache(targetName);
    cacheClearedOnce[targetName] = true;
}
/////////////////////////////////////////////////////////////////////
// tsc handling
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.filterPathsByTime" id="apidoc.element.grunt-ts.cacheUtils.filterPathsByTime">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>filterPathsByTime
        <span class="apidocSignatureSpan">(paths, targetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterPathsByTime(paths, targetName) {
    var time = getLastSuccessfullCompile(targetName);
    return getFilesNewerThan(paths, time);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.getNewFilesForTarget" id="apidoc.element.grunt-ts.cacheUtils.getNewFilesForTarget">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>getNewFilesForTarget
        <span class="apidocSignatureSpan">(paths, targetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNewFilesForTarget(paths, targetName) {
    var step1 = filterPathsByTime(paths, targetName);
    var step2 = filterPathsByHash(step1, targetName);
    return step2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
/////////////////////////////////////////////////////////////////
// Fast Compilation
/////////////////////////////////////////////////////////////////
// Map to store if the cache was cleared after the gruntfile was parsed
var cacheClearedOnce = {};
function getChangedFiles(files, targetName) {
files = cache.<span class="apidocCodeKeywordSpan">getNewFilesForTarget</span>(files, targetName);
_.forEach(files, function (file) {
    exports.grunt.log.writeln((&#x27;### Fast Compile &#x3e;&#x3e;&#x27; + file).cyan);
});
return files;
}
function resetChangedFiles(files, targetName) {
cache.compileSuccessfull(files, targetName);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.compile" id="apidoc.module.grunt-ts.compile">module grunt-ts.compile</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.compile.compileAllFiles" id="apidoc.element.grunt-ts.compile.compileAllFiles">
        function <span class="apidocSignatureSpan">grunt-ts.compile.</span>compileAllFiles
        <span class="apidocSignatureSpan">(options, compilationInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileAllFiles(options, compilationInfo) {
    var targetFiles = compilationInfo.src;
    // Make a local copy so we can modify files without having external side effects
    var files = _.map(targetFiles, function (file) { return file; });
    var newFiles = files;
    if (options.fast === &#x27;watch&#x27;) {
        // if this is the first time its running after this file was loaded
        if (cacheClearedOnce[exports.grunt.task.current.target] === undefined) {
            // Then clear the cache for this target
            clearCache(options.targetName);
        }
    }
    if (options.fast !== &#x27;never&#x27;) {
        if (compilationInfo.out) {
            exports.grunt.log.writeln(&#x27;Fast compile will not work when --out is specified. Ignoring fast compilation&#x27;.cyan);
        }
        else {
            newFiles = getChangedFiles(files, options.targetName);
            if (newFiles.length !== 0 || options.testExecute || utils.shouldPassThrough(options)) {
                files = newFiles;
                // If outDir is specified but no baseDir is specified we need to determine one
                if (compilationInfo.outDir &#x26;&#x26; !options.baseDir) {
                    options.baseDir = utils.findCommonPath(files, &#x27;/&#x27;);
                }
            }
            else {
                exports.grunt.log.writeln(&#x27;No file changes were detected. Skipping Compile&#x27;.green);
                return new es6_promise_1.Promise(function (resolve) {
                    var ret = {
                        code: 0,
                        fileCount: 0,
                        output: &#x27;No files compiled as no change detected&#x27;
                    };
                    resolve(ret);
                });
            }
        }
    }
    // Transform files as needed. Currently all of this logic in is one module
    // transformers.transformFiles(newFiles, targetFiles, target, task);
    // If baseDir is specified create a temp tsc file to make sure that `--outDir` works fine
    // see https://github.com/grunt-ts/grunt-ts/issues/77
    var baseDirFile = &#x27;.baseDir.ts&#x27;;
    var baseDirFilePath;
    if (compilationInfo.outDir &#x26;&#x26; options.baseDir &#x26;&#x26; files.length &#x3e; 0) {
        baseDirFilePath = path.join(options.baseDir, baseDirFile);
        if (!fs.existsSync(baseDirFilePath)) {
            exports.grunt.file.write(baseDirFilePath, &#x27;// Ignore this file. See https://github.com/grunt-ts/grunt-ts/issues/77&#x27;);
        }
        files.push(baseDirFilePath);
    }
    // If reference and out are both specified.
    // Then only compile the updated reference file as that contains the correct order
    if (options.reference &#x26;&#x26; compilationInfo.out) {
        var referenceFile = path.resolve(options.reference);
        files = [referenceFile];
    }
    // Quote the files to compile. Needed for command line parsing by tsc
    files = _.map(files, function (item) { return (&#x22;\&#x22;&#x22; + path.resolve(item) + &#x22;\&#x22;&#x22;); });
    var args = files.slice(0), tsc, tscVersion = &#x27;&#x27;;
    var tsconfig = options.tsconfig;
    if (options.compiler) {
        // Custom compiler (task.compiler)
        exports.grunt.log.writeln(&#x27;Using the custom compiler : &#x27; + options.compiler);
        tsc = options.compiler;
        tscVersion = &#x27;&#x27;;
    }
    else {
        // the bundled OR npm module based compiler
        var tscPath = resolveTypeScriptBinPath();
        tsc = getTsc(tscPath);
        tscVersion = getTscVersion(tscPath);
        exports.grunt.log.writeln(&#x27;Using tsc v&#x27; + tscVersion);
    }
    if (tsconfig &#x26;&#x26; tsconfig.passThrough) {
        args.push(&#x27;--project&#x27;, tsconfig.tsconfig);
    }
    else {
        if (options.sourceMap) {
            args.push(&#x27;--sourcemap&#x27;);
        }
        if (options.emitDecoratorMetadata) {
            args.push(&#x27;--emitDecoratorMetadata&#x27;);
        }
        if (options.declaration) {
            args.push(&#x27;--declaration&#x27;);
        }
        if (options.removeComments) {
            args.push(&#x27;--removeComments&#x27;);
        }
        if (options.noImplicitAny) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// logs errors
function runCompilation(options, compilationInfo) {
    grunt.log.writeln(&#x27;Compiling...&#x27;.yellow);
    // Time the compiler process
    var starttime = new Date().getTime();
    var endtime;
    // Compile the files
    return compileModule.<span class="apidocCodeKeywordSpan">compileAllFiles</span>(options, compilationInfo)
        .then(function (result) {
        // End the timer
        endtime = new Date().getTime();
        grunt.log.writeln(&#x27;&#x27;);
        // Analyze the results of our tsc execution,
        //   then tell the user our analysis results
        //   and mark the build as fail or success
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.compile.compileResultMeansFastCacheShouldBeRefreshed" id="apidoc.element.grunt-ts.compile.compileResultMeansFastCacheShouldBeRefreshed">
        function <span class="apidocSignatureSpan">grunt-ts.compile.</span>compileResultMeansFastCacheShouldBeRefreshed
        <span class="apidocSignatureSpan">(options, result)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileResultMeansFastCacheShouldBeRefreshed(options, result) {
    return (options.fast !== &#x27;never&#x27; &#x26;&#x26;
        (result.code === 0 || (result.code === 2 &#x26;&#x26; !options.failOnTypeErrors)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.html2ts" id="apidoc.module.grunt-ts.html2ts">module grunt-ts.html2ts</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.html2ts.compileHTML" id="apidoc.element.grunt-ts.html2ts.compileHTML">
        function <span class="apidocSignatureSpan">grunt-ts.html2ts.</span>compileHTML
        <span class="apidocSignatureSpan">(filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileHTML(filename, options) {
    grunt.log.verbose.writeln(&#x27;Compiling HTML: &#x27; + filename);
    var htmlContent = escapeContent(fs.readFileSync(filename).toString());
    htmlContent = stripBOM(htmlContent);
    // TODO: place a minification pipeline here if you want.
    var ext = path.extname(filename).replace(&#x27;.&#x27;, &#x27;&#x27;);
    var extFreename = path.basename(filename, &#x27;.&#x27; + ext);
    var moduleName = toCamel(options.moduleFunction({ ext: ext, filename: extFreename }));
    var varName = toCamel(options.varFunction({ ext: ext, filename: extFreename }).replace(/\./g, &#x27;_&#x27;));
    var fileContent;
    if (!options.htmlOutputTemplate) {
        fileContent = _.template(htmlInternalTemplate(options.eol))({ modulename: moduleName, varname: varName, content: htmlContent
 });
    }
    else {
        fileContent = _.template(replaceNewLines(options.htmlOutputTemplate, options.eol))({ modulename: moduleName, varname: varName
, content: htmlContent });
    }
    // Write the content to a file
    var outputfile = getOutputFile(filename, options.htmlOutDir, options.flatten);
    mkdirParent(path.dirname(outputfile));
    fs.writeFileSync(outputfile, fileContent);
    return outputfile;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        varFunction: _.template(options.htmlVarTemplate),
        htmlOutputTemplate: options.htmlOutputTemplate,
        htmlOutDir: options.htmlOutDir,
        flatten: options.htmlOutDirFlatten,
        eol: (options.newLine || utils.eol)
    };
    var htmlFiles = grunt.file.expand(options.html);
    generatedFiles = _.map(htmlFiles, function (filename) { return html2tsModule.<span class="apidocCodeKeywordSpan">compileHTML
</span>(filename, html2tsOptions_1); });
    generatedFiles.forEach(function (fileName) {
        if (filesToCompile.indexOf(fileName) === -1 &#x26;&#x26;
            grunt.file.isMatch(currentFiles.glob, fileName)) {
            filesToCompile.push(fileName);
        }
    });
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.optionsResolver" id="apidoc.module.grunt-ts.optionsResolver">module grunt-ts.optionsResolver</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.optionsResolver.resolveAsync" id="apidoc.element.grunt-ts.optionsResolver.resolveAsync">
        function <span class="apidocSignatureSpan">grunt-ts.optionsResolver.</span>resolveAsync
        <span class="apidocSignatureSpan">(rawTaskOptions, rawTargetOptions, targetName, resolvedFiles, theTemplateProcessor, theGlobExpander)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveAsync(rawTaskOptions, rawTargetOptions, targetName, resolvedFiles, theTemplateProcessor, theGlobExpander) {
    if (targetName === void 0) { targetName = &#x27;&#x27;; }
    if (resolvedFiles === void 0) { resolvedFiles = []; }
    if (theTemplateProcessor === void 0) { theTemplateProcessor = null; }
    if (theGlobExpander === void 0) { theGlobExpander = null; }
    var result = emptyOptionsResolveResult();
    return new es6_promise_1.Promise(function (resolve, reject) {
        if (theTemplateProcessor &#x26;&#x26; typeof theTemplateProcessor === &#x27;function&#x27;) {
            templateProcessor = theTemplateProcessor;
        }
        else {
            templateProcessor = noopTemplateProcessor;
        }
        if (theGlobExpander &#x26;&#x26; typeof theGlobExpander === &#x27;function&#x27;) {
            globExpander = theGlobExpander;
        }
        else {
            globExpander = emptyGlobExpander;
        }
        fixMissingOptions(rawTaskOptions);
        fixMissingOptions(rawTargetOptions);
        {
            var _a = resolveAndWarnOnConfigurationIssues(rawTaskOptions, rawTargetOptions, targetName), errors = _a.errors, warnings
 = _a.warnings;
            (_b = result.errors).push.apply(_b, errors);
            (_c = result.warnings).push.apply(_c, warnings);
        }
        result = applyGruntOptions(result, rawTaskOptions);
        result = applyGruntOptions(result, rawTargetOptions);
        result = copyCompilationTasks(result, resolvedFiles, resolveOutputOptions(rawTaskOptions, rawTargetOptions));
        visualStudioOptionsResolver_1.resolveVSOptionsAsync(result, rawTaskOptions, rawTargetOptions, templateProcessor).then(function
 (result) {
            tsconfig_1.resolveAsync(result, rawTaskOptions, rawTargetOptions, templateProcessor, globExpander).then(function (result
) {
                result = addressAssociatedOptionsAndResolveConflicts(result);
                result = enclosePathsInQuotesIfRequired(result);
                result = logAdditionalConfigurationWarnings(result);
                result = applyGruntTSDefaults(result);
                if (result.targetName === undefined ||
                    (!result.targetName &#x26;&#x26; targetName)) {
                    result.targetName = targetName;
                }
                return resolve(result);
            }).catch(function (tsConfigError) {
                result.errors.push(&#x27;tsconfig error: &#x27; + JSON.stringify(tsConfigError));
                return resolve(result);
            });
        }).catch(function (vsConfigError) {
            result.errors.push(&#x27;Visual Studio config issue: &#x27; + JSON.stringify(vsConfigError));
            return resolve(result);
        });
        var _b, _c;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentGruntTask = this;
var resolvedFiles = currentGruntTask.files;
// make async
done = currentGruntTask.async();
// get unprocessed templates from configuration
var rawTaskConfig = (grunt.config.getRaw(currentGruntTask.name) || {});
var rawTargetConfig = (grunt.config.getRaw(currentGruntTask.name + &#x27;.&#x27; + currentGruntTask.target) || {});
optionsResolver.<span class="apidocCodeKeywordSpan">resolveAsync</span>(rawTaskConfig, rawTargetConfig, currentGruntTask.target,
resolvedFiles, grunt.template.process, grunt.file.expand).then(function (result) {
    options = result;
    options.warnings.forEach(function (warning) {
        grunt.log.writeln(warning.magenta);
    });
    options.errors.forEach(function (error) {
        grunt.log.writeln(error.red);
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.reference" id="apidoc.module.grunt-ts.reference">module grunt-ts.reference</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.reference.updateReferenceFile" id="apidoc.element.grunt-ts.reference.updateReferenceFile">
        function <span class="apidocSignatureSpan">grunt-ts.reference.</span>updateReferenceFile
        <span class="apidocSignatureSpan">(files, generatedFiles, referenceFile, referencePath, eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateReferenceFile(files, generatedFiles, referenceFile, referencePath, eol) {
    var referenceIntro = &#x27;/// &#x3c;reference path=&#x22;&#x27;;
    var referenceEnd = &#x27;&#x22; /&#x3e;&#x27;;
    var referenceMatch = /\/\/\/ &#x3c;reference path=\&#x22;(.*?)\&#x22;/;
    var ourSignatureStart = &#x27;//grunt-start&#x27;;
    var ourSignatureEnd = &#x27;//grunt-end&#x27;;
    // remove the generated files from files:
    files = _.difference(files, generatedFiles);
    var lines = []; // All lines of the file
    var origFileLines = []; // The lines we do not modify and send out as is. Lines will we reach grunt-ts generated
    var origFileReferences = []; // The list of files already there that we do not need to manage
    // Location of our generated references
    // By default at start of file
    var signatureSectionPosition = 0;
    var i;
    // Read the original file if it exists
    var referenceContents = &#x27;&#x27;;
    if (fs.existsSync(referenceFile)) {
        referenceContents = fs.readFileSync(referenceFile).toString();
        lines = referenceContents.split(/\r\n|\r|\n/);
        var inSignatureSection = false;
        // By default our signature goes at end of file
        signatureSectionPosition = lines.length;
        for (i = 0; i &#x3c; lines.length; i++) {
            var line = _str.trim(lines[i]);
            // Skip logic for our generated section
            if (_str.include(line, ourSignatureStart)) {
                // Wait for the end signature:
                signatureSectionPosition = i;
                inSignatureSection = true;
                continue;
            }
            if (_str.include(line, ourSignatureEnd)) {
                inSignatureSection = false;
                continue;
            }
            if (inSignatureSection) {
                continue;
            }
            // store the line
            origFileLines.push(line);
            // Fetch the existing reference&#x27;s filename if any:
            if (_str.include(line, referenceIntro)) {
                var match = line.match(referenceMatch);
                var filename = match[1];
                origFileReferences.push(filename);
            }
        }
    }
    // Put in the generated files
    generatedFiles = _.map(generatedFiles, function (file) { return referenceIntro + utils.makeRelativePath(referencePath, file) +
referenceEnd; });
    var contents = utils.insertArrayAt([ourSignatureStart], 1, generatedFiles);
    // Put in the new / observed missing files:
    files.forEach(function (filename) {
        // The file we are about to add
        var filepath = utils.makeRelativePath(referencePath, filename);
        // If there are orig references
        if (origFileReferences.length) {
            if (_.contains(origFileReferences, filepath)) {
                return;
            }
        }
        // Finally add the filepath
        contents.push(referenceIntro + filepath + referenceEnd);
    });
    contents.push(ourSignatureEnd);
    var updatedFileLines = utils.insertArrayAt(origFileLines, signatureSectionPosition, contents);
    var updatedFileContents = updatedFileLines.join(eol);
    // Modify the orig contents to put in our contents only if changed
    // Also Return whether the file was changed
    if (updatedFileContents !== referenceContents) {
        grunt.file.write(referenceFile, updatedFileContents);
        return true;
    }
    else {
        return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
///// Reference File
// Generate the reference file
// Create a reference file if specified
if (!!referencePath) {
    var result = timeIt(function () {
        return referenceModule.<span class="apidocCodeKeywordSpan">updateReferenceFile</span>(filesToCompile.filter(function (f) {
return !isReferenceFile(f); }), generatedFiles, referenceFile, referencePath, (options.newLine || utils.eol));
    });
    if (result.it === true) {
        grunt.log.writeln((&#x27;Updated reference file (&#x27; + result.time + &#x27;ms).&#x27;).green);
    }
}
///// AMD loader
// Create the amdLoader if specified
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.templateCache" id="apidoc.module.grunt-ts.templateCache">module grunt-ts.templateCache</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.templateCache.generateTemplateCache" id="apidoc.element.grunt-ts.templateCache.generateTemplateCache">
        function <span class="apidocSignatureSpan">grunt-ts.templateCache.</span>generateTemplateCache
        <span class="apidocSignatureSpan">(src, dest, basePath, eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateTemplateCache(src, dest, basePath, eol) {
    if (!src.length) {
        return;
    }
    // Resolve the relative path from basePath to each src file
    var relativePaths = _.map(src, function (anHtmlFile) { return &#x27;text!&#x27; + utils.makeRelativePath(basePath, anHtmlFile); });
    var fileNames = _.map(src, function (anHtmlFile) { return path.basename(anHtmlFile); });
    var fileVarialbeName = function (anHtmlFile) { return anHtmlFile.split(&#x27;.&#x27;).join(&#x27;_&#x27;).split(&#x27;-&#x27;).join(&#x27;_&#x27;); };
    var fileVariableNames = _.map(fileNames, fileVarialbeName);
    var templateCacheTemplate = _.template(&#x27;// You must have requirejs + text plugin loaded for this to work.&#x27;
        + eol + &#x27;define([&#x3c;%=relativePathSection%&#x3e;],function(&#x3c;%=fileNameVariableSection%&#x3e;){&#x27;
        + eol + &#x27;angular.module(&#x22;ng&#x22;).run([&#x22;$templateCache&#x22;,function($templateCache) {&#x27;
        + eol + &#x27;&#x3c;%=templateCachePut%&#x3e;&#x27;
        + eol + &#x27;}]);&#x27;
        + eol + &#x27;});&#x27;);
    var relativePathSection = &#x27;&#x22;&#x27; + relativePaths.join(&#x27;&#x22;,&#x27; + eol + &#x27;&#x22;&#x27;) + &#x27;&#x22;&#x27;;
    var fileNameVariableSection = fileVariableNames.join(&#x27;,&#x27; + eol);
    var templateCachePutTemplate = _.template(&#x27;$templateCache.put(&#x22;&#x3c;%= fileName %&#x3e;&#x22;, &#x3c;%=fileVariableName%&#x3e;);&#x27;);
    var templateCachePut = _.map(fileNames, function (fileName) { return templateCachePutTemplate({
        fileName: fileName,
        fileVariableName: fileVarialbeName(fileName)
    }); }).join(eol);
    var fileContent = templateCacheTemplate({
        relativePathSection: relativePathSection,
        fileNameVariableSection: fileNameVariableSection,
        templateCachePut: templateCachePut
    });
    // Early exit if new templateCache doesn&#x27;t change
    if (fs.existsSync(dest)) {
        var originalContents = fs.readFileSync(dest).toString();
        if (originalContents === fileContent) {
            return;
        }
    }
    // write updated contents
    fs.writeFileSync(dest, fileContent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!options.templateCache.src || !options.templateCache.dest || !options.templateCache.baseUrl) {
        grunt.log.writeln(&#x27;templateCache : src, dest, baseUrl must be specified if templateCache option is used&#x27;.red);
    }
    else {
        var templateCacheSrc = grunt.file.expand(options.templateCache.src); // manual reinterpolation
        var templateCacheDest = path.resolve(options.templateCache.dest);
        var templateCacheBasePath = path.resolve(options.templateCache.baseUrl);
        templateCacheModule.<span class="apidocCodeKeywordSpan">generateTemplateCache</span>(templateCacheSrc, templateCacheDest
, templateCacheBasePath, (options.newLine || utils.eol));
    }
}
///// Reference File
// Generate the reference file
// Create a reference file if specified
if (!!referencePath) {
    var result = timeIt(function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.transformers" id="apidoc.module.grunt-ts.transformers">module grunt-ts.transformers</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.transformers.transformFiles" id="apidoc.element.grunt-ts.transformers.transformFiles">
        function <span class="apidocSignatureSpan">grunt-ts.transformers.</span>transformFiles
        <span class="apidocSignatureSpan">(changedFiles, targetFiles, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformFiles(changedFiles, targetFiles, options) {
    currentTargetDirs = getTargetFolders(targetFiles);
    currentTargetFiles = targetFiles;
    ///////////////////////////////////// transformation
    var transformers = [
        new ImportTransformer(),
        new ExportTransformer((options.newLine || utils.eol)),
        new ReferenceTransformer(),
        new UnknownTransformer()
    ];
    _.forEach(changedFiles, function (fileToProcess) {
        var contents = fs.readFileSync(fileToProcess).toString().replace(/^\uFEFF/, &#x27;&#x27;);
        // If no signature don&#x27;t bother with this file
        if (!BaseTransformer.containsTransformSignature(contents)) {
            return;
        }
        var lines = contents.split(/\r\n|\r|\n/);
        var outputLines = [];
        for (var i = 0; i &#x3c; lines.length; i++) {
            var line = lines[i];
            //// Debugging
            // grunt.log.writeln(&#x27;line&#x27;.green);
            // grunt.log.writeln(line);
            // Skip generated lines as these will get regenerated
            if (_.some(transformers, function (transformer) { return transformer.isGenerated(line); })) {
                continue;
            }
            // Directive line
            if (_.some(transformers, function (transformer) {
                var match = transformer.matches(line);
                if (match) {
                    // The code gen directive line automatically qualifies
                    outputLines.push(line);
                    // pass transform settings to transform (match[1] is the equals sign, ensure it exists but otherwise ignore
it)
                    outputLines.push.apply(outputLines, transformer.transform(fileToProcess, match[1] &#x26;&#x26; match[2] &#x26;&#x26; match[2].trim
()));
                    return true;
                }
                return false;
            })) {
                continue;
            }
            // Lines not generated or not directives
            outputLines.push(line);
        }
        var transformedContent = outputLines.join(utils.eol);
        if (transformedContent !== contents) {
            grunt.file.write(fileToProcess, transformedContent);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
///// AMD loader
// Create the amdLoader if specified
if (!!amdloaderPath) {
    var referenceOrder = amdLoaderModule.getReferencesInOrder(referenceFile, referencePath, generatedFiles);
    amdLoaderModule.updateAmdLoader(referenceFile, referenceOrder, amdloaderFile, amdloaderPath, currentFiles.outDir);
}
// Transform files as needed. Currently all of this logic in is one module
transformers.<span class="apidocCodeKeywordSpan">transformFiles</span>(filesToCompile /*TODO: only unchanged files*/, filesToCompile
, options);
currentFiles.src = filesToCompile;
// Return promise to compliation
if (utils.shouldCompile(options)) {
    if (filesToCompile.length &#x3e; 0 || options.testExecute || utils.shouldPassThrough(options)) {
        return runCompilation(options, currentFiles).then(function (success) {
            return success;
        });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.tsconfig" id="apidoc.module.grunt-ts.tsconfig">module grunt-ts.tsconfig</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.tsconfig.resolveAsync" id="apidoc.element.grunt-ts.tsconfig.resolveAsync">
        function <span class="apidocSignatureSpan">grunt-ts.tsconfig.</span>resolveAsync
        <span class="apidocSignatureSpan">(applyTo, taskOptions, targetOptions, theTemplateProcessor, theGlobExpander)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveAsync(applyTo, taskOptions, targetOptions, theTemplateProcessor, theGlobExpander) {
    if (theGlobExpander === void 0) { theGlobExpander = null; }
    templateProcessor = theTemplateProcessor;
    globExpander = theGlobExpander;
    gruntfileGlobs = getGlobs(taskOptions, targetOptions);
    return new es6_promise_1.Promise(function (resolve, reject) {
        try {
            var taskTSConfig = getTSConfigSettings(taskOptions);
            var targetTSConfig = getTSConfigSettings(targetOptions);
            var tsconfig = null;
            if (taskTSConfig) {
                tsconfig = taskTSConfig;
            }
            if (targetTSConfig) {
                if (!tsconfig) {
                    tsconfig = targetTSConfig;
                }
                if (&#x27;tsconfig&#x27; in targetTSConfig) {
                    tsconfig.tsconfig = templateProcessor(targetTSConfig.tsconfig, {});
                }
                if (&#x27;ignoreSettings&#x27; in targetTSConfig) {
                    tsconfig.ignoreSettings = targetTSConfig.ignoreSettings;
                }
                if (&#x27;overwriteFilesGlob&#x27; in targetTSConfig) {
                    tsconfig.overwriteFilesGlob = targetTSConfig.overwriteFilesGlob;
                }
                if (&#x27;updateFiles&#x27; in targetTSConfig) {
                    tsconfig.updateFiles = targetTSConfig.updateFiles;
                }
                if (&#x27;passThrough&#x27; in targetTSConfig) {
                    tsconfig.passThrough = targetTSConfig.passThrough;
                }
            }
            applyTo.tsconfig = tsconfig;
        }
        catch (ex) {
            return reject(ex);
        }
        if (!applyTo.tsconfig) {
            return resolve(applyTo);
        }
        if (applyTo.tsconfig.passThrough) {
            if (applyTo.CompilationTasks.length === 0) {
                applyTo.CompilationTasks.push({ src: [] });
            }
            if (!applyTo.tsconfig.tsconfig) {
                applyTo.tsconfig.tsconfig = &#x27;.&#x27;;
            }
        }
        else {
            var projectFile = applyTo.tsconfig.tsconfig;
            try {
                var projectFileTextContent = fs.readFileSync(projectFile, &#x27;utf8&#x27;);
            }
            catch (ex) {
                if (ex &#x26;&#x26; ex.code === &#x27;ENOENT&#x27;) {
                    return reject(&#x27;Could not find file &#x22;&#x27; + projectFile + &#x27;&#x22;.&#x27;);
                }
                else if (ex &#x26;&#x26; ex.errno) {
                    return reject(&#x27;Error &#x27; + ex.errno + &#x27; reading &#x22;&#x27; + projectFile + &#x27;&#x22;.&#x27;);
                }
                else {
                    return reject(&#x27;Error reading &#x22;&#x27; + projectFile + &#x27;&#x22;: &#x27; + JSON.stringify(ex));
                }
            }
            try {
                var projectSpec;
                var content = stripBom(projectFileTextContent);
                if (content.trim() === &#x27;&#x27;) {
                    projectSpec = {};
                }
                else {
                    projectSpec = JSON.parse(content);
                }
            }
            catch (ex) {
                return reject(&#x27;Error parsing &#x22;&#x27; + projectFile + &#x27;&#x22;.  It may not be valid JSON in UTF-8.&#x27;);
            }
            applyTo = warnOnBadConfiguration(applyTo, projectSpec);
            applyTo = applyCompilerOptions(applyTo, projectSpec);
            applyTo = resolve_output_locations(applyTo, projectSpec);
        }
        resolve(applyTo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentGruntTask = this;
var resolvedFiles = currentGruntTask.files;
// make async
done = currentGruntTask.async();
// get unprocessed templates from configuration
var rawTaskConfig = (grunt.config.getRaw(currentGruntTask.name) || {});
var rawTargetConfig = (grunt.config.getRaw(currentGruntTask.name + &#x27;.&#x27; + currentGruntTask.target) || {});
optionsResolver.<span class="apidocCodeKeywordSpan">resolveAsync</span>(rawTaskConfig, rawTargetConfig, currentGruntTask.target,
resolvedFiles, grunt.template.process, grunt.file.expand).then(function (result) {
    options = result;
    options.warnings.forEach(function (warning) {
        grunt.log.writeln(warning.magenta);
    });
    options.errors.forEach(function (error) {
        grunt.log.writeln(error.red);
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.utils" id="apidoc.module.grunt-ts.utils">module grunt-ts.utils</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.utils.asyncSeries" id="apidoc.element.grunt-ts.utils.asyncSeries">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>asyncSeries
        <span class="apidocSignatureSpan">(items, callPerItem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncSeries(items, callPerItem) {
    items = items.slice(0);
    var memo = [];
    // Run one at a time
    return new es6_promise_1.Promise(function (resolve, reject) {
        var next = function () {
            if (items.length === 0) {
                resolve(memo);
                return;
            }
            es6_promise_1.Promise
                .cast(callPerItem(items.shift()))
                .then(function (result) {
                memo.push(result);
                next();
            }, reject);
        };
        next();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.copyFile" id="apidoc.element.grunt-ts.utils.copyFile">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>copyFile
        <span class="apidocSignatureSpan">(srcFile, destFile, callback, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyFile(srcFile, destFile, callback, encoding) {
    if (encoding === void 0) { encoding = &#x27;utf8&#x27;; }
    fs.readFile(srcFile, encoding, function (err, data) {
        fs.writeFile(destFile, data, encoding, function (err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.enclosePathInQuotesIfRequired" id="apidoc.element.grunt-ts.utils.enclosePathInQuotesIfRequired">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>enclosePathInQuotesIfRequired
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enclosePathInQuotesIfRequired(path) {
    if (!path || !path.indexOf) {
        return path;
    }
    if (path.indexOf(&#x27; &#x27;) === -1) {
        return path;
    }
    else {
        var newPath = path.trim();
        if (newPath.indexOf(&#x27;&#x22;&#x27;) === 0 &#x26;&#x26; newPath.lastIndexOf(&#x27;&#x22;&#x27;) === newPath.length - 1) {
            return newPath;
        }
        else {
            return &#x27;&#x22;&#x27; + newPath + &#x27;&#x22;&#x27;;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0; i &#x3c; resolvedFiles.length; i += 1) {
var glob = void 0;
var orig = resolvedFiles[i].orig;
if (orig &#x26;&#x26; (&#x27;src&#x27; in orig)) {
    glob = [].concat(orig.src);
}
var compilationSet = {
    src: _.map(resolvedFiles[i].src, function (fileName) { return utils.<span class="apidocCodeKeywordSpan">enclosePathInQuotesIfRequired
</span>(fileName); }),
    out: utils.enclosePathInQuotesIfRequired(resolvedFiles[i].out),
    outDir: utils.enclosePathInQuotesIfRequired(resolvedFiles[i].outDir),
    glob: glob
};
if (&#x27;dest&#x27; in resolvedFiles[i] &#x26;&#x26; resolvedFiles[i].dest) {
    var dest = void 0;
    if (_.isArray(resolvedFiles[i].dest)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.endsWith" id="apidoc.element.grunt-ts.utils.endsWith">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>endsWith
        <span class="apidocSignatureSpan">(str, suffix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endsWith(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
lastCompile = new Date().getTime();
// Run initial compile
return filterFilesTransformAndCompile();
// local event to handle file event
function handleFileEvent(filepath, displaystr, addedOrChanged) {
    if (addedOrChanged === void 0) { addedOrChanged = false; }
    // Only ts and html :
    if (!utils.<span class="apidocCodeKeywordSpan">endsWith</span>(filepath.toLowerCase(), &#x27;.ts&#x27;) &#x26;&#x26; !utils.
endsWith(filepath.toLowerCase(), &#x27;.html&#x27;)) {
        return;
    }
    // Do not run if just ran, behaviour same as grunt-watch
    // These are the files our run modified
    if ((new Date().getTime() - lastCompile) &#x3c;= 100) {
        // Uncomment for debugging which files were ignored
        // grunt.log.writeln((&#x27; ///&#x27;  + &#x27; &#x3e;&#x3e;&#x27; + filepath).grey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.findCommonPath" id="apidoc.element.grunt-ts.utils.findCommonPath">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>findCommonPath
        <span class="apidocSignatureSpan">(paths, pathSeperator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findCommonPath(paths, pathSeperator) {
    // Now for &#x22;C:\u\starter&#x22; &#x22;C:\u\started&#x22; =&#x3e; &#x22;C:\u\starte&#x22;
    var largetStartSegement = sharedStart(paths);
    // For &#x22;C:\u\starte&#x22; =&#x3e; C:\u\
    var ending = largetStartSegement.lastIndexOf(pathSeperator);
    return largetStartSegement.substr(0, ending);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return path.resolve(filename) === outFile_d_ts;
}
// see https://github.com/grunt-ts/grunt-ts/issues/77
function isBaseDirFile(filename, targetFiles) {
    var baseDirFile = &#x27;.baseDir.ts&#x27;;
    var bd = &#x27;&#x27;;
    if (!options.baseDir) {
        bd = utils.<span class="apidocCodeKeywordSpan">findCommonPath</span>(targetFiles, &#x27;/&#x27;);
        options.baseDir = bd;
    }
    return path.resolve(filename) === path.resolve(path.join(bd, baseDirFile));
}
// Create an amd loader?
var amdloader = options.amdloader;
var amdloaderFile, amdloaderPath;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.firstElementWithValue" id="apidoc.element.grunt-ts.utils.firstElementWithValue">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>firstElementWithValue
        <span class="apidocSignatureSpan">(elements, defaultResult)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function firstElementWithValue(elements, defaultResult) {
    if (defaultResult === void 0) { defaultResult = null; }
    var result = defaultResult;
    _.each(elements, function (item) {
        if (hasValue(item)) {
            result = item;
            return false; // break out of lodash loop
        }
        return undefined;
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.format" id="apidoc.element.grunt-ts.utils.format">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>format
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function format(str) {
    var args = [];
    for (var _i = 1; _i &#x3c; arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return str.replace(/{(\d+)}/g, function (m, i) {
        return args[i] !== undefined ? args[i] : m;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
});
return Object.keys(folders);
}
var BaseTransformer = (function () {
function BaseTransformer(key, variableSyntax) {
    this.key = key;
    this.match = new RegExp(utils.<span class="apidocCodeKeywordSpan">format</span>(BaseTransformer.tsTransformerMatch, key));
    this.signature = this.tripleSlashTS() + key;
    this.signatureGenerated = this.signature + &#x27;:generated&#x27;;
    this.syntaxError = &#x27;/// Invalid syntax for ts:&#x27; + this.key + &#x27;=&#x27; + variableSyntax + &#x27; &#x27; + this
.signatureGenerated;
}
BaseTransformer.prototype.tripleSlashTS = function () {
    // This is a function and broken into two strings to prevent the transformers module from
    // transforming *itself* (a-la Skynet).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getDirs" id="apidoc.element.grunt-ts.utils.getDirs">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getDirs
        <span class="apidocSignatureSpan">(dirPath, exclude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDirs(dirPath, exclude) {
    return _getAll(dirPath, exclude, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getFiles" id="apidoc.element.grunt-ts.utils.getFiles">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getFiles
        <span class="apidocSignatureSpan">(dirPath, exclude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFiles(dirPath, exclude) {
    return _getAll(dirPath, exclude, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// use index.ts instead of all the files in the directory
if (getIndexIfDir
    &#x26;&#x26; fs.existsSync(possibleIndexFilePath)
    &#x26;&#x26; path.relative(currentFilePath, possibleIndexFilePath) !== &#x27;&#x27;) {
    files.push(path.join(targetDir, &#x27;index.ts&#x27;));
}
else {
    var filesInDir = utils.<span class="apidocCodeKeywordSpan">getFiles</span>(targetDir, function (filename) {
        // exclude current file
        if (path.relative(currentFilePath, filename) === &#x27;&#x27;) {
            return true;
        }
        return path.extname(filename) // must have extension : do not exclude directories
            &#x26;&#x26; (!_str.endsWith(filename, &#x27;.ts&#x27;) || _str.endsWith(filename, &#x27;.d.ts&#x27;))
            &#x26;&#x26; !fs.lstatSync(filename).isDirectory(); // for people that name directories with dots
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getOrGetFirst" id="apidoc.element.grunt-ts.utils.getOrGetFirst">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getOrGetFirst
        <span class="apidocSignatureSpan">(getFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOrGetFirst(getFrom) {
    if (_.isArray(getFrom)) {
        if (getFrom.length &#x3e; 0) {
            return getFrom[0];
        }
        return &#x27;&#x27;;
    }
    return getFrom;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getRandomHex" id="apidoc.element.grunt-ts.utils.getRandomHex">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getRandomHex
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomHex(length) {
    if (length === void 0) { length = 16; }
    var name = &#x27;&#x27;;
    do {
        name += Math.round(Math.random() * Math.pow(16, 8)).toString(16);
    } while (name.length &#x3c; length);
    return name.substr(0, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getTempFile" id="apidoc.element.grunt-ts.utils.getTempFile">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getTempFile
        <span class="apidocSignatureSpan">(prefix, dir, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTempFile(prefix, dir, extension) {
    if (dir === void 0) { dir = &#x27;&#x27;; }
    if (extension === void 0) { extension = &#x27;.tmp.txt&#x27;; }
    prefix = (prefix ? prefix + &#x27;-&#x27; : &#x27;&#x27;);
    var attempts = 100;
    do {
        var name = prefix + getRandomHex(8) + extension;
        var dest = path.join(dir, name);
        if (!fs.existsSync(dest)) {
            return dest;
        }
        attempts--;
    } while (attempts &#x3e; 0);
    throw &#x27;Cannot create temp file in &#x27; + dir;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.log(args.join(&#x27; &#x27;).yellow);
}
else {
    exports.grunt.log.verbose.writeln(args.join(&#x27; &#x27;).yellow);
}
// Create a temp last command file and use that to guide tsc.
// Reason: passing all the files on the command line causes TSC to go in an infinite loop.
var tempfilename = utils.<span class="apidocCodeKeywordSpan">getTempFile</span>(&#x27;tscommand&#x27;);
if (!tempfilename) {
    throw (new Error(&#x27;cannot create temp file&#x27;));
}
fs.writeFileSync(tempfilename, args.join(&#x27; &#x27;));
var command;
// Switch implementation if a test version of executeNode exists.
if (&#x27;testExecute&#x27; in options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.hasValue" id="apidoc.element.grunt-ts.utils.hasValue">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>hasValue
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasValue(thing) {
    return !_.isNull(thing) &#x26;&#x26; !_.isUndefined(thing);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}
function applyGruntOptions(applyTo, gruntOptions) {
if (gruntOptions) {
    for (var _i = 0, propertiesFromTarget_1 = propertiesFromTarget; _i &#x3c; propertiesFromTarget_1.length; _i++) {
        var propertyName = propertiesFromTarget_1[_i];
        if (propertyName in gruntOptions &#x26;&#x26; propertyName !== &#x27;vs&#x27;) {
            if (typeof gruntOptions[propertyName] === &#x27;string&#x27; &#x26;&#x26; utils.<span class="apidocCodeKeywordSpan">
hasValue</span>(gruntOptions[propertyName]) &#x26;&#x26;
                delayTemplateExpansion.indexOf(propertyName) === -1) {
                applyTo[propertyName] = templateProcessor(gruntOptions[propertyName], {});
            }
            else {
                applyTo[propertyName] = gruntOptions[propertyName];
            }
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.insertArrayAt" id="apidoc.element.grunt-ts.utils.insertArrayAt">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>insertArrayAt
        <span class="apidocSignatureSpan">(array, index, arrayToInsert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertArrayAt(array, index, arrayToInsert) {
    var updated = array.slice(0);
    var spliceAt = [index, 0];
    Array.prototype.splice.apply(updated, spliceAt.concat(arrayToInsert));
    return updated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            var filename = match[1];
            origFileReferences.push(filename);
        }
    }
}
// Put in the generated files
generatedFiles = _.map(generatedFiles, function (file) { return referenceIntro + utils.makeRelativePath(referencePath, file) + referenceEnd
; });
var contents = utils.<span class="apidocCodeKeywordSpan">insertArrayAt</span>([ourSignatureStart], 1, generatedFiles);
// Put in the new / observed missing files:
files.forEach(function (filename) {
    // The file we are about to add
    var filepath = utils.makeRelativePath(referencePath, filename);
    // If there are orig references
    if (origFileReferences.length) {
        if (_.contains(origFileReferences, filepath)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.isJavaScriptFile" id="apidoc.element.grunt-ts.utils.isJavaScriptFile">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>isJavaScriptFile
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJavaScriptFile(filePath) {
    if (filePath.toLowerCase) {
        var normalizedFile = path.resolve(stripQuotesIfQuoted(filePath)).toLowerCase();
        return endsWith(normalizedFile, &#x27;.js&#x27;);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (compilationInfo.out) {
    // We only pass --out instead of --outFile for backward-compatability reasons.
    // It is the same for purposes of the command-line (the subtle difference is handled in the tsconfig code
    //  and the value of --outFile is copied to --out).
    args.push(&#x27;--out&#x27;, compilationInfo.out);
}
if (compilationInfo.dest &#x26;&#x26; (!compilationInfo.out) &#x26;&#x26; (!compilationInfo.outDir)) {
    if (utils.<span class="apidocCodeKeywordSpan">isJavaScriptFile</span>(compilationInfo.dest)) {
        args.push(&#x27;--out&#x27;, compilationInfo.dest);
    }
    else {
        if (compilationInfo.dest === &#x27;src&#x27;) {
            console.warn((&#x27;WARNING: Destination for target &#x22;&#x27; + options.targetName + &#x27;&#x22; is &#x22;src&#x22
;, which is the default.  If you have&#x27; +
                &#x27; forgotten to specify a &#x22;dest&#x22; parameter, please add it.  If this is correct, you may wish&#x27; +
                &#x27; to change the &#x22;dest&#x22; parameter to &#x22;src/&#x22; or just ignore this warning.&#x27;).magenta);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.makeRelativePath" id="apidoc.element.grunt-ts.utils.makeRelativePath">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>makeRelativePath
        <span class="apidocSignatureSpan">(folderpath, filename, forceRelative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeRelativePath(folderpath, filename, forceRelative) {
    if (forceRelative === void 0) { forceRelative = false; }
    var relativePath = path.relative(folderpath, filename).split(&#x27;\\&#x27;).join(&#x27;/&#x27;);
    if (forceRelative &#x26;&#x26; relativePath[0] !== &#x27;.&#x27;) {
        relativePath = &#x27;./&#x27; + relativePath;
    }
    return relativePath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var makeRelativeToOutDir = function (files) {
    files = _.map(files, function (file) {
        // Remove common path and replace with absolute outDir
        file = file.replace(commonPath, outDir);
        // remove extension &#x27;.ts&#x27; / &#x27;.tsx&#x27;:
        file = file.substr(0, file.lastIndexOf(&#x27;.&#x27;));
        // Make relative to amd loader
        file = utils.<span class="apidocCodeKeywordSpan">makeRelativePath</span>(loaderPath, file);
        // Prepend &#x22;./&#x22; to prevent &#x22;basePath&#x22; requirejs setting from interferring:
        file = &#x27;./&#x27; + file;
        return file;
    });
    return files;
};
// Read the original file if it exists
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.newLineActualAsParameter" id="apidoc.element.grunt-ts.utils.newLineActualAsParameter">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineActualAsParameter
        <span class="apidocSignatureSpan">(actualNewLineChars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newLineActualAsParameter(actualNewLineChars) {
    if (actualNewLineChars) {
        return actualNewLineChars.replace(/\n/g, &#x27;LF&#x27;).replace(/\r/g, &#x27;CR&#x27;);
    }
    return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.newLineIsRedundantForTsc" id="apidoc.element.grunt-ts.utils.newLineIsRedundantForTsc">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineIsRedundantForTsc
        <span class="apidocSignatureSpan">(newLineParameter, operatingSystem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newLineIsRedundantForTsc(newLineParameter, operatingSystem) {
    if (operatingSystem === void 0) { operatingSystem = os; }
    return ((newLineParameter === &#x27;CRLF&#x27; &#x26;&#x26; operatingSystem.EOL === &#x27;\r\n&#x27;) ||
        (newLineParameter === &#x27;LF&#x27; &#x26;&#x26; operatingSystem.EOL === &#x27;\n&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (options.inlineSources) {
    args.push(&#x27;--inlineSources&#x27;);
}
if (options.inlineSourceMap) {
    args.push(&#x27;--inlineSourceMap&#x27;);
}
if (options.newLine &#x26;&#x26; !utils.<span class="apidocCodeKeywordSpan">newLineIsRedundantForTsc</span>(options.newLine)) {
    args.push(&#x27;--newLine&#x27;, options.newLine);
}
if (options.isolatedModules) {
    args.push(&#x27;--isolatedModules&#x27;);
}
if (options.noEmitHelpers) {
    args.push(&#x27;--noEmitHelpers&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.newLineParameterAsActual" id="apidoc.element.grunt-ts.utils.newLineParameterAsActual">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineParameterAsActual
        <span class="apidocSignatureSpan">(parameterNewLineChars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newLineParameterAsActual(parameterNewLineChars) {
    if (parameterNewLineChars) {
        return parameterNewLineChars.replace(/LF/g, &#x27;\n&#x27;).replace(/CR/g, &#x27;\r&#x27;);
    }
    return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.readAndParseJSONFromFileSync" id="apidoc.element.grunt-ts.utils.readAndParseJSONFromFileSync">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>readAndParseJSONFromFileSync
        <span class="apidocSignatureSpan">(fileName, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readAndParseJSONFromFileSync(fileName, encoding) {
    if (encoding === void 0) { encoding = &#x27;utf8&#x27;; }
    var textContent, result;
    try {
        textContent = fs.readFileSync(fileName, encoding);
    }
    catch (ex) {
        throw new Error(&#x22;Error reading file &#x22; + fileName + &#x22;: &#x22; + ex);
    }
    try {
        result = JSON.parse(textContent);
    }
    catch (ex) {
        throw new Error(&#x22;Error parsing JSON in file &#x22; + fileName + &#x22;: &#x22; + ex);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0; i &#x3c; filesRelativeToGruntfile.length; i += 1) {
        filesRelativeToGruntfile[i] = filesRelativeToGruntfile[i].replace(/\\/g, &#x27;/&#x27;);
        filesRelativeToTSConfig_temp.push(path.relative(relativePathFromGruntfileToTSConfig_1, filesRelativeToGruntfile[i]).replace
(/\\/g, &#x27;/&#x27;));
    }
    filesRelativeToTSConfig.length = 0;
    filesRelativeToTSConfig.push.apply(filesRelativeToTSConfig, filesRelativeToTSConfig_temp);
}
var tsconfigJSONContent = utils.<span class="apidocCodeKeywordSpan">readAndParseJSONFromFileSync</span>(tsconfigFileName);
var tempTSConfigFiles = tsconfigJSONContent.files || [];
if (_.difference(tempTSConfigFiles, filesRelativeToTSConfig).length &#x3e; 0 ||
    _.difference(filesRelativeToTSConfig, tempTSConfigFiles).length &#x3e; 0) {
    try {
        tsconfigJSONContent.files = filesRelativeToTSConfig;
        saveTSConfigSync(tsconfigFileName, tsconfigJSONContent);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.shouldCompile" id="apidoc.element.grunt-ts.utils.shouldCompile">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>shouldCompile
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldCompile(options) {
    return !!options.compile;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var referenceOrder = amdLoaderModule.getReferencesInOrder(referenceFile, referencePath, generatedFiles);
    amdLoaderModule.updateAmdLoader(referenceFile, referenceOrder, amdloaderFile, amdloaderPath, currentFiles.outDir);
}
// Transform files as needed. Currently all of this logic in is one module
transformers.transformFiles(filesToCompile /*TODO: only unchanged files*/, filesToCompile, options);
currentFiles.src = filesToCompile;
// Return promise to compliation
if (utils.<span class="apidocCodeKeywordSpan">shouldCompile</span>(options)) {
    if (filesToCompile.length &#x3e; 0 || options.testExecute || utils.shouldPassThrough(options)) {
        return runCompilation(options, currentFiles).then(function (success) {
            return success;
        });
    }
    else {
        // Nothing to do
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.shouldPassThrough" id="apidoc.element.grunt-ts.utils.shouldPassThrough">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>shouldPassThrough
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldPassThrough(options) {
    return (options.tsconfig &#x26;&#x26; options.tsconfig.passThrough);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isSuccessfulBuild = (!isError ||
    (isError &#x26;&#x26; isOnlyTypeErrors &#x26;&#x26; !options.failOnTypeErrors));
if (isSuccessfulBuild) {
    // Report successful build.
    var time = (endtime - starttime) / 1000;
    grunt.log.writeln(&#x27;&#x27;);
    var message = &#x27;TypeScript compilation complete: &#x27; + time.toFixed(2) + &#x27;s&#x27;;
    if (utils.<span class="apidocCodeKeywordSpan">shouldPassThrough</span>(options)) {
        message += &#x27; for TypeScript pass-through.&#x27;;
    }
    else {
        message += &#x27; for &#x27; + result.fileCount + &#x27; TypeScript files.&#x27;;
    }
    grunt.log.writeln(message.green);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.stripQuotesIfQuoted" id="apidoc.element.grunt-ts.utils.stripQuotesIfQuoted">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>stripQuotesIfQuoted
        <span class="apidocSignatureSpan">(possiblyQuotedString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stripQuotesIfQuoted(possiblyQuotedString) {
    if (!possiblyQuotedString.length || possiblyQuotedString.length &#x3c; 2) {
        return possiblyQuotedString;
    }
    if (possiblyQuotedString.charAt(0) === &#x27;&#x22;&#x27; &#x26;&#x26;
        possiblyQuotedString.charAt(possiblyQuotedString.length - 1) === &#x27;&#x22;&#x27;) {
        return possiblyQuotedString.substr(1, possiblyQuotedString.length - 2);
    }
    return possiblyQuotedString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.timeIt" id="apidoc.element.grunt-ts.utils.timeIt">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>timeIt
        <span class="apidocSignatureSpan">(makeIt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeIt(makeIt) {
    var starttime = new Date().getTime();
    var it = makeIt();
    var endtime = new Date().getTime();
    return {
        it: it,
        time: endtime - starttime
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.visualStudioOptionsResolver" id="apidoc.module.grunt-ts.visualStudioOptionsResolver">module grunt-ts.visualStudioOptionsResolver</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.visualStudioOptionsResolver.resolveVSOptionsAsync" id="apidoc.element.grunt-ts.visualStudioOptionsResolver.resolveVSOptionsAsync">
        function <span class="apidocSignatureSpan">grunt-ts.visualStudioOptionsResolver.</span>resolveVSOptionsAsync
        <span class="apidocSignatureSpan">(applyTo, taskOptions, targetOptions, theTemplateProcessor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveVSOptionsAsync(applyTo, taskOptions, targetOptions, theTemplateProcessor) {
    templateProcessor = theTemplateProcessor;
    return new es6_promise_1.Promise(function (resolve, reject) {
        {
            var vsTask = getVSSettings(taskOptions), vsTarget = getVSSettings(targetOptions);
            var vs = null;
            if (vsTask) {
                vs = vsTask;
            }
            if (vsTarget) {
                if (!vs) {
                    vs = vsTarget;
                }
                if (vsTarget.project) {
                    vs.project = vsTarget.project;
                }
                if (vsTarget.config) {
                    vs.config = vsTarget.config;
                }
                if (vsTarget.ignoreFiles) {
                    vs.ignoreFiles = vsTarget.ignoreFiles;
                }
                if (vsTarget.ignoreSettings) {
                    vs.ignoreSettings = vsTarget.ignoreSettings;
                }
            }
            if (vs) {
                applyTo.vs = vs;
                if (typeof applyTo.vs.project === &#x27;string&#x27;) {
                    applyTo.vs.project = templateProcessor(applyTo.vs.project, {});
                }
                if (typeof applyTo.vs.config === &#x27;string&#x27;) {
                    applyTo.vs.config = templateProcessor(applyTo.vs.config, {});
                }
            }
        }
        if (applyTo.vs) {
            return csproj2ts.getTypeScriptSettings({
                ProjectFileName: applyTo.vs.project,
                ActiveConfiguration: applyTo.vs.config || undefined
            }).then(function (vsConfig) {
                try {
                    applyTo = applyVSOptions(applyTo, vsConfig);
                    applyTo = resolve_out_and_outDir(applyTo, taskOptions, targetOptions);
                    return resolve(applyTo);
                }
                catch (ex) {
                    return reject(ex);
                }
            }).catch(function (error) {
                if (error.errno === 34) {
                    applyTo.errors.push(&#x27;In target &#x22;&#x27; + applyTo.targetName + &#x27;&#x22; - could not find VS project at &#x22;&#x27; + error.path + &#x27;&#x22;.&#x27;);
                }
                else {
                    applyTo.errors.push(&#x27;In target &#x22;&#x27; + applyTo.targetName + &#x27;&#x22;.  Error #&#x27; + error.errno + &#x27;.  &#x27; + error);
                }
                return reject(error);
            });
        }
        return resolve(applyTo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var _a = resolveAndWarnOnConfigurationIssues(rawTaskOptions, rawTargetOptions, targetName), errors = _a.errors, warnings = _a
.warnings;
    (_b = result.errors).push.apply(_b, errors);
    (_c = result.warnings).push.apply(_c, warnings);
}
result = applyGruntOptions(result, rawTaskOptions);
result = applyGruntOptions(result, rawTargetOptions);
result = copyCompilationTasks(result, resolvedFiles, resolveOutputOptions(rawTaskOptions, rawTargetOptions));
visualStudioOptionsResolver_1.<span class="apidocCodeKeywordSpan">resolveVSOptionsAsync</span>(result, rawTaskOptions, rawTargetOptions
, templateProcessor).then(function (result) {
    tsconfig_1.resolveAsync(result, rawTaskOptions, rawTargetOptions, templateProcessor, globExpander).then(function (result) {
        result = addressAssociatedOptionsAndResolveConflicts(result);
        result = enclosePathsInQuotesIfRequired(result);
        result = logAdditionalConfigurationWarnings(result);
        result = applyGruntTSDefaults(result);
        if (result.targetName === undefined ||
            (!result.targetName &#x26;&#x26; targetName)) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
