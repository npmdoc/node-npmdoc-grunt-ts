<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/TypeStrong/grunt-ts">grunt-ts (v5.5.1)</a>
</h1>
<h4>Compile and manage your TypeScript project</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts">module grunt-ts</a><ol>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>amdLoader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>cacheUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>compile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>html2ts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>optionsResolver</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>reference</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>templateCache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>transformers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>tsconfig</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.</span>visualStudioOptionsResolver</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.amdLoader">module grunt-ts.amdLoader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.amdLoader.getReferencesInOrder">
            function <span class="apidocSignatureSpan">grunt-ts.amdLoader.</span>getReferencesInOrder
            <span class="apidocSignatureSpan">(referenceFile, referencePath, generatedFiles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.amdLoader.updateAmdLoader">
            function <span class="apidocSignatureSpan">grunt-ts.amdLoader.</span>updateAmdLoader
            <span class="apidocSignatureSpan">(referenceFile, files, loaderFile, loaderPath, outDir, newLine)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.cacheUtils">module grunt-ts.cacheUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.anyNewerThan">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>anyNewerThan
            <span class="apidocSignatureSpan">(paths, time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.clearCache">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>clearCache
            <span class="apidocSignatureSpan">(targetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.compileSuccessfull">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>compileSuccessfull
            <span class="apidocSignatureSpan">(paths, targetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.filterPathsByTime">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>filterPathsByTime
            <span class="apidocSignatureSpan">(paths, targetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.cacheUtils.getNewFilesForTarget">
            function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>getNewFilesForTarget
            <span class="apidocSignatureSpan">(paths, targetName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>cacheDir</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.compile">module grunt-ts.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.compile.compileAllFiles">
            function <span class="apidocSignatureSpan">grunt-ts.compile.</span>compileAllFiles
            <span class="apidocSignatureSpan">(options, compilationInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.compile.compileResultMeansFastCacheShouldBeRefreshed">
            function <span class="apidocSignatureSpan">grunt-ts.compile.</span>compileResultMeansFastCacheShouldBeRefreshed
            <span class="apidocSignatureSpan">(options, result)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.compile.</span>grunt</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.html2ts">module grunt-ts.html2ts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.html2ts.compileHTML">
            function <span class="apidocSignatureSpan">grunt-ts.html2ts.</span>compileHTML
            <span class="apidocSignatureSpan">(filename, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.optionsResolver">module grunt-ts.optionsResolver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.optionsResolver.resolveAsync">
            function <span class="apidocSignatureSpan">grunt-ts.optionsResolver.</span>resolveAsync
            <span class="apidocSignatureSpan">(rawTaskOptions, rawTargetOptions, targetName, resolvedFiles, theTemplateProcessor, theGlobExpander)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.reference">module grunt-ts.reference</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.reference.updateReferenceFile">
            function <span class="apidocSignatureSpan">grunt-ts.reference.</span>updateReferenceFile
            <span class="apidocSignatureSpan">(files, generatedFiles, referenceFile, referencePath, eol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.templateCache">module grunt-ts.templateCache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.templateCache.generateTemplateCache">
            function <span class="apidocSignatureSpan">grunt-ts.templateCache.</span>generateTemplateCache
            <span class="apidocSignatureSpan">(src, dest, basePath, eol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.transformers">module grunt-ts.transformers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.transformers.transformFiles">
            function <span class="apidocSignatureSpan">grunt-ts.transformers.</span>transformFiles
            <span class="apidocSignatureSpan">(changedFiles, targetFiles, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.tsconfig">module grunt-ts.tsconfig</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.tsconfig.resolveAsync">
            function <span class="apidocSignatureSpan">grunt-ts.tsconfig.</span>resolveAsync
            <span class="apidocSignatureSpan">(applyTo, taskOptions, targetOptions, theTemplateProcessor, theGlobExpander)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.utils">module grunt-ts.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.asyncSeries">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>asyncSeries
            <span class="apidocSignatureSpan">(items, callPerItem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.copyFile">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>copyFile
            <span class="apidocSignatureSpan">(srcFile, destFile, callback, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.enclosePathInQuotesIfRequired">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>enclosePathInQuotesIfRequired
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.endsWith">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>endsWith
            <span class="apidocSignatureSpan">(str, suffix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.findCommonPath">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>findCommonPath
            <span class="apidocSignatureSpan">(paths, pathSeperator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.firstElementWithValue">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>firstElementWithValue
            <span class="apidocSignatureSpan">(elements, defaultResult)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.format">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>format
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getDirs">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getDirs
            <span class="apidocSignatureSpan">(dirPath, exclude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getFiles">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getFiles
            <span class="apidocSignatureSpan">(dirPath, exclude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getOrGetFirst">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getOrGetFirst
            <span class="apidocSignatureSpan">(getFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getRandomHex">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getRandomHex
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.getTempFile">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getTempFile
            <span class="apidocSignatureSpan">(prefix, dir, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.hasValue">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>hasValue
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.insertArrayAt">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>insertArrayAt
            <span class="apidocSignatureSpan">(array, index, arrayToInsert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.isJavaScriptFile">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>isJavaScriptFile
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.makeRelativePath">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>makeRelativePath
            <span class="apidocSignatureSpan">(folderpath, filename, forceRelative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.newLineActualAsParameter">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineActualAsParameter
            <span class="apidocSignatureSpan">(actualNewLineChars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.newLineIsRedundantForTsc">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineIsRedundantForTsc
            <span class="apidocSignatureSpan">(newLineParameter, operatingSystem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.newLineParameterAsActual">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineParameterAsActual
            <span class="apidocSignatureSpan">(parameterNewLineChars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.readAndParseJSONFromFileSync">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>readAndParseJSONFromFileSync
            <span class="apidocSignatureSpan">(fileName, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.shouldCompile">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>shouldCompile
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.shouldPassThrough">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>shouldPassThrough
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.stripQuotesIfQuoted">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>stripQuotesIfQuoted
            <span class="apidocSignatureSpan">(possiblyQuotedString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.utils.timeIt">
            function <span class="apidocSignatureSpan">grunt-ts.utils.</span>timeIt
            <span class="apidocSignatureSpan">(makeIt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-ts.utils.</span>grunt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">grunt-ts.utils.</span>eol</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-ts.visualStudioOptionsResolver">module grunt-ts.visualStudioOptionsResolver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-ts.visualStudioOptionsResolver.resolveVSOptionsAsync">
            function <span class="apidocSignatureSpan">grunt-ts.visualStudioOptionsResolver.</span>resolveVSOptionsAsync
            <span class="apidocSignatureSpan">(applyTo, taskOptions, targetOptions, theTemplateProcessor)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts" id="apidoc.module.grunt-ts">module grunt-ts</a></h1>























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.amdLoader" id="apidoc.module.grunt-ts.amdLoader">module grunt-ts.amdLoader</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.amdLoader.getReferencesInOrder" id="apidoc.element.grunt-ts.amdLoader.getReferencesInOrder">
        function <span class="apidocSignatureSpan">grunt-ts.amdLoader.</span>getReferencesInOrder
        <span class="apidocSignatureSpan">(referenceFile, referencePath, generatedFiles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getReferencesInOrder(referenceFile, referencePath, generatedFiles) {
    var toreturn = {
        all: [],
        before: [],
        generated: [],
        unordered: [],
        after: []
    };
    var sortedGeneratedFiles = _.sortBy(generatedFiles);
    function isGeneratedFile(filename) {
        return _.indexOf(sortedGeneratedFiles, filename, true) !== -1;
    }
    // When reading
    var referenceMatch = /\/\/\/ &lt;reference path=\"(.*?)\"/;
    // When writing
    var referenceIntro = '/// &lt;reference path="';
    // var referenceEnd = '" /&gt;';
    // The section of unordered files
    var ourSignatureStart = '//grunt-start';
    var ourSignatureEnd = '//grunt-end';
    var lines = fs.readFileSync(referenceFile).toString().split('\n');
    // Which of the three sections we are in
    var loopState = 0 /* before */;
    for (var i = 0; i &lt; lines.length; i++) {
        var line = _str.trim(lines[i]);
        if (_str.include(line, ourSignatureStart)) {
            // Wait for the end signature:
            loopState = 1 /* unordered */;
        }
        if (_str.include(line, ourSignatureEnd)) {
            loopState = 2 /* after */;
        }
        // Fetch the existing reference's filename if any:
        if (_str.include(line, referenceIntro)) {
            var match = line.match(referenceMatch);
            var filename = match[1];
            switch (loopState) {
                case 0 /* before */:
                    toreturn.before.push(filename);
                    break;
                case 1 /* unordered */:
                    if (isGeneratedFile(filename)) {
                        toreturn.generated.push(filename);
                    }
                    else {
                        toreturn.unordered.push(filename);
                    }
                    break;
                case 2 /* after */:
                    toreturn.after.push(filename);
                    break;
            }
        }
    }
    // Fix the references to be absolute:
    toreturn.before = _.map(toreturn.before, function (relativePath) { return path.resolve(referencePath, relativePath); });
    toreturn.generated = _.map(toreturn.generated, function (relativePath) { return path.resolve(referencePath, relativePath); });
    toreturn.unordered = _.map(toreturn.unordered, function (relativePath) { return path.resolve(referencePath, relativePath); });
    toreturn.after = _.map(toreturn.after, function (relativePath) { return path.resolve(referencePath, relativePath); });
    toreturn.all = Array.prototype.concat.call([], toreturn.before, toreturn.generated, toreturn.unordered, toreturn.after);
    return toreturn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (result.it === true) {
        grunt.log.writeln(('Updated reference file (' + result.time + 'ms).').green);
    }
}
///// AMD loader
// Create the amdLoader if specified
if (!!amdloaderPath) {
    var referenceOrder = amdLoaderModule.<span class="apidocCodeKeywordSpan">getReferencesInOrder</span>(referenceFile, referencePath
, generatedFiles);
    amdLoaderModule.updateAmdLoader(referenceFile, referenceOrder, amdloaderFile, amdloaderPath, currentFiles.outDir);
}
// Transform files as needed. Currently all of this logic in is one module
transformers.transformFiles(filesToCompile /*TODO: only unchanged files*/, filesToCompile, options);
currentFiles.src = filesToCompile;
// Return promise to compliation
if (utils.shouldCompile(options)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.amdLoader.updateAmdLoader" id="apidoc.element.grunt-ts.amdLoader.updateAmdLoader">
        function <span class="apidocSignatureSpan">grunt-ts.amdLoader.</span>updateAmdLoader
        <span class="apidocSignatureSpan">(referenceFile, files, loaderFile, loaderPath, outDir, newLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAmdLoader(referenceFile, files, loaderFile, loaderPath, outDir, newLine) {
    if (newLine === void 0) { newLine = utils.eol; }
    var commonPath;
    var makeRelativeToOutDir = function (files) {
        files = _.map(files, function (file) {
            // Remove common path and replace with absolute outDir
            file = file.replace(commonPath, outDir);
            // remove extension '.ts' / '.tsx':
            file = file.substr(0, file.lastIndexOf('.'));
            // Make relative to amd loader
            file = utils.makeRelativePath(loaderPath, file);
            // Prepend "./" to prevent "basePath" requirejs setting from interferring:
            file = './' + file;
            return file;
        });
        return files;
    };
    // Read the original file if it exists
    if (fs.existsSync(referenceFile)) {
        grunt.log.verbose.writeln('Generating amdloader from reference file ' + referenceFile);
        // Filter.d.ts,
        if (files.all.length &gt; 0) {
            grunt.log.verbose.writeln('Files: ' + files.all.map(function (f) { return f.cyan; }).join(', '));
        }
        else {
            grunt.warn('No files in reference file: ' + referenceFile);
        }
        if (files.before.length &gt; 0) {
            files.before = _.filter(files.before, function (file) { return !utils.endsWith(file, '.d.ts'); });
            grunt.log.verbose.writeln('Before: ' + files.before.map(function (f) { return f.cyan; }).join(', '));
        }
        if (files.generated.length &gt; 0) {
            files.generated = _.filter(files.generated, function (file) { return !utils.endsWith(file, '.d.ts'); });
            grunt.log.verbose.writeln('Generated: ' + files.generated.map(function (f) { return f.cyan; }).join(', '));
        }
        if (files.unordered.length &gt; 0) {
            files.unordered = _.filter(files.unordered, function (file) { return !utils.endsWith(file, '.d.ts'); });
            grunt.log.verbose.writeln('Unordered: ' + files.unordered.map(function (f) { return f.cyan; }).join(', '));
        }
        if (files.after.length &gt; 0) {
            files.after = _.filter(files.after, function (file) { return !utils.endsWith(file, '.d.ts'); });
            grunt.log.verbose.writeln('After: ' + files.after.map(function (f) { return f.cyan; }).join(', '));
        }
        // If target has outDir we need to make adjust the path
        // c:/somefolder/ts/a , c:/somefolder/ts/inside/b  + c:/somefolder/build/js =&gt; c:/somefolder/build/js/a , c:/somefolder/
build/js/inside/b
        // Logic:
        //     find the common structure in the source files ,and remove it
        //          Finally: outDir path + remainder section
        if (outDir) {
            // Find common path
            commonPath = utils.findCommonPath(files.before.concat(files.generated.concat(files.unordered.concat(files.after))),
pathSeperator);
            grunt.log.verbose.writeln('Found common path: ' + commonPath);
            // Make sure outDir is absolute:
            outDir = path.resolve(outDir);
            grunt.log.verbose.writeln('Using outDir: ' + outDir);
            grunt.log.verbose.writeln('Making files relative to outDir...');
            files.before = makeRelativeToOutDir(files.before);
            files.generated = makeRelativeToOutDir(files.generated);
            files.unordered = makeRelativeToOutDir(files.unordered);
            files.after = makeRelativeToOutDir(files.after);
            var mainTemplate = _.template('define(function (require) { '
                + newLine + '&lt;%= body %&gt;'
                + newLine + '});');
            // The order in the before and after files is important
            var singleRequireTemplate = _.template('\t require([&lt;%= filename %&gt;],function (){'
                + newLine + '&lt;%= subitem %&gt;'
                + newLine + '\t });');
            // initial sub item
            var subitem = '';
            // Write out a binary file:
            var binaryTemplate = _.template ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        grunt.log.writeln(('Updated reference file (' + result.time + 'ms).').green);
    }
}
///// AMD loader
// Create the amdLoader if specified
if (!!amdloaderPath) {
    var referenceOrder = amdLoaderModule.getReferencesInOrder(referenceFile, referencePath, generatedFiles);
    amdLoaderModule.<span class="apidocCodeKeywordSpan">updateAmdLoader</span>(referenceFile, referenceOrder, amdloaderFile, amdloaderPath
, currentFiles.outDir);
}
// Transform files as needed. Currently all of this logic in is one module
transformers.transformFiles(filesToCompile /*TODO: only unchanged files*/, filesToCompile, options);
currentFiles.src = filesToCompile;
// Return promise to compliation
if (utils.shouldCompile(options)) {
    if (filesToCompile.length &gt; 0 || options.testExecute || utils.shouldPassThrough(options)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.cacheUtils" id="apidoc.module.grunt-ts.cacheUtils">module grunt-ts.cacheUtils</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.anyNewerThan" id="apidoc.element.grunt-ts.cacheUtils.anyNewerThan">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>anyNewerThan
        <span class="apidocSignatureSpan">(paths, time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function anyNewerThan(paths, time) {
    return getFilesNewerThan(paths, time).length &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.clearCache" id="apidoc.element.grunt-ts.cacheUtils.clearCache">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>clearCache
        <span class="apidocSignatureSpan">(targetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearCache(targetName) {
    var cacheDirForTarget = path.join(exports.cacheDir, targetName);
    try {
        if (fs.existsSync(cacheDirForTarget)) {
            rimraf.sync(cacheDirForTarget);
            grunt.log.writeln(('Cleared fast compile cache for target: ' + targetName).cyan);
        }
    }
    catch (ex) {
        grunt.log.writeln(('Failed to clear compile cache for target: ' + targetName).red);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
return files;
}
function resetChangedFiles(files, targetName) {
cache.compileSuccessfull(files, targetName);
}
function clearCache(targetName) {
cache.<span class="apidocCodeKeywordSpan">clearCache</span>(targetName);
cacheClearedOnce[targetName] = true;
}
/////////////////////////////////////////////////////////////////////
// tsc handling
////////////////////////////////////////////////////////////////////
function resolveTypeScriptBinPath() {
var ownRoot = path.resolve(path.dirname((module).filename), '../..');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.compileSuccessfull" id="apidoc.element.grunt-ts.cacheUtils.compileSuccessfull">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>compileSuccessfull
        <span class="apidocSignatureSpan">(paths, targetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileSuccessfull(paths, targetName) {
    // update timestamp
    grunt.file.write(getStampPath(targetName), '');
    // update filehash
    updateHashes(paths, targetName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    files = cache.getNewFilesForTarget(files, targetName);
    _.forEach(files, function (file) {
        exports.grunt.log.writeln(('### Fast Compile &gt;&gt;' + file).cyan);
    });
    return files;
}
function resetChangedFiles(files, targetName) {
    cache.<span class="apidocCodeKeywordSpan">compileSuccessfull</span>(files, targetName);
}
function clearCache(targetName) {
    cache.clearCache(targetName);
    cacheClearedOnce[targetName] = true;
}
/////////////////////////////////////////////////////////////////////
// tsc handling
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.filterPathsByTime" id="apidoc.element.grunt-ts.cacheUtils.filterPathsByTime">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>filterPathsByTime
        <span class="apidocSignatureSpan">(paths, targetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterPathsByTime(paths, targetName) {
    var time = getLastSuccessfullCompile(targetName);
    return getFilesNewerThan(paths, time);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.cacheUtils.getNewFilesForTarget" id="apidoc.element.grunt-ts.cacheUtils.getNewFilesForTarget">
        function <span class="apidocSignatureSpan">grunt-ts.cacheUtils.</span>getNewFilesForTarget
        <span class="apidocSignatureSpan">(paths, targetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNewFilesForTarget(paths, targetName) {
    var step1 = filterPathsByTime(paths, targetName);
    var step2 = filterPathsByHash(step1, targetName);
    return step2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
/////////////////////////////////////////////////////////////////
// Fast Compilation
/////////////////////////////////////////////////////////////////
// Map to store if the cache was cleared after the gruntfile was parsed
var cacheClearedOnce = {};
function getChangedFiles(files, targetName) {
files = cache.<span class="apidocCodeKeywordSpan">getNewFilesForTarget</span>(files, targetName);
_.forEach(files, function (file) {
    exports.grunt.log.writeln(('### Fast Compile &gt;&gt;' + file).cyan);
});
return files;
}
function resetChangedFiles(files, targetName) {
cache.compileSuccessfull(files, targetName);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.compile" id="apidoc.module.grunt-ts.compile">module grunt-ts.compile</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.compile.compileAllFiles" id="apidoc.element.grunt-ts.compile.compileAllFiles">
        function <span class="apidocSignatureSpan">grunt-ts.compile.</span>compileAllFiles
        <span class="apidocSignatureSpan">(options, compilationInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileAllFiles(options, compilationInfo) {
    var targetFiles = compilationInfo.src;
    // Make a local copy so we can modify files without having external side effects
    var files = _.map(targetFiles, function (file) { return file; });
    var newFiles = files;
    if (options.fast === 'watch') {
        // if this is the first time its running after this file was loaded
        if (cacheClearedOnce[exports.grunt.task.current.target] === undefined) {
            // Then clear the cache for this target
            clearCache(options.targetName);
        }
    }
    if (options.fast !== 'never') {
        if (compilationInfo.out) {
            exports.grunt.log.writeln('Fast compile will not work when --out is specified. Ignoring fast compilation'.cyan);
        }
        else {
            newFiles = getChangedFiles(files, options.targetName);
            if (newFiles.length !== 0 || options.testExecute || utils.shouldPassThrough(options)) {
                files = newFiles;
                // If outDir is specified but no baseDir is specified we need to determine one
                if (compilationInfo.outDir &amp;&amp; !options.baseDir) {
                    options.baseDir = utils.findCommonPath(files, '/');
                }
            }
            else {
                exports.grunt.log.writeln('No file changes were detected. Skipping Compile'.green);
                return new es6_promise_1.Promise(function (resolve) {
                    var ret = {
                        code: 0,
                        fileCount: 0,
                        output: 'No files compiled as no change detected'
                    };
                    resolve(ret);
                });
            }
        }
    }
    // Transform files as needed. Currently all of this logic in is one module
    // transformers.transformFiles(newFiles, targetFiles, target, task);
    // If baseDir is specified create a temp tsc file to make sure that `--outDir` works fine
    // see https://github.com/grunt-ts/grunt-ts/issues/77
    var baseDirFile = '.baseDir.ts';
    var baseDirFilePath;
    if (compilationInfo.outDir &amp;&amp; options.baseDir &amp;&amp; files.length &gt; 0) {
        baseDirFilePath = path.join(options.baseDir, baseDirFile);
        if (!fs.existsSync(baseDirFilePath)) {
            exports.grunt.file.write(baseDirFilePath, '// Ignore this file. See https://github.com/grunt-ts/grunt-ts/issues/77');
        }
        files.push(baseDirFilePath);
    }
    // If reference and out are both specified.
    // Then only compile the updated reference file as that contains the correct order
    if (options.reference &amp;&amp; compilationInfo.out) {
        var referenceFile = path.resolve(options.reference);
        files = [referenceFile];
    }
    // Quote the files to compile. Needed for command line parsing by tsc
    files = _.map(files, function (item) { return ("\"" + path.resolve(item) + "\""); });
    var args = files.slice(0), tsc, tscVersion = '';
    var tsconfig = options.tsconfig;
    if (options.compiler) {
        // Custom compiler (task.compiler)
        exports.grunt.log.writeln('Using the custom compiler : ' + options.compiler);
        tsc = options.compiler;
        tscVersion = '';
    }
    else {
        // the bundled OR npm module based compiler
        var tscPath = resolveTypeScriptBinPath();
        tsc = getTsc(tscPath);
        tscVersion = getTscVersion(tscPath);
        exports.grunt.log.writeln('Using tsc v' + tscVersion);
    }
    if (tsconfig &amp;&amp; tsconfig.passThrough) {
        args.push('--project', tsconfig.tsconfig);
    }
    else {
        if (options.sourceMap) {
            args.push('--sourcemap');
        }
        if (options.emitDecoratorMetadata) {
            args.push('--emitDecoratorMetadata');
        }
        if (options.declaration) {
            args.push('--declaration');
        }
        if (options.removeComments) {
            args.push('--removeComments');
        }
        if (options.noImplicitAny) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// logs errors
function runCompilation(options, compilationInfo) {
    grunt.log.writeln('Compiling...'.yellow);
    // Time the compiler process
    var starttime = new Date().getTime();
    var endtime;
    // Compile the files
    return compileModule.<span class="apidocCodeKeywordSpan">compileAllFiles</span>(options, compilationInfo)
        .then(function (result) {
        // End the timer
        endtime = new Date().getTime();
        grunt.log.writeln('');
        // Analyze the results of our tsc execution,
        //   then tell the user our analysis results
        //   and mark the build as fail or success
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.compile.compileResultMeansFastCacheShouldBeRefreshed" id="apidoc.element.grunt-ts.compile.compileResultMeansFastCacheShouldBeRefreshed">
        function <span class="apidocSignatureSpan">grunt-ts.compile.</span>compileResultMeansFastCacheShouldBeRefreshed
        <span class="apidocSignatureSpan">(options, result)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileResultMeansFastCacheShouldBeRefreshed(options, result) {
    return (options.fast !== 'never' &amp;&amp;
        (result.code === 0 || (result.code === 2 &amp;&amp; !options.failOnTypeErrors)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.html2ts" id="apidoc.module.grunt-ts.html2ts">module grunt-ts.html2ts</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.html2ts.compileHTML" id="apidoc.element.grunt-ts.html2ts.compileHTML">
        function <span class="apidocSignatureSpan">grunt-ts.html2ts.</span>compileHTML
        <span class="apidocSignatureSpan">(filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileHTML(filename, options) {
    grunt.log.verbose.writeln('Compiling HTML: ' + filename);
    var htmlContent = escapeContent(fs.readFileSync(filename).toString());
    htmlContent = stripBOM(htmlContent);
    // TODO: place a minification pipeline here if you want.
    var ext = path.extname(filename).replace('.', '');
    var extFreename = path.basename(filename, '.' + ext);
    var moduleName = toCamel(options.moduleFunction({ ext: ext, filename: extFreename }));
    var varName = toCamel(options.varFunction({ ext: ext, filename: extFreename }).replace(/\./g, '_'));
    var fileContent;
    if (!options.htmlOutputTemplate) {
        fileContent = _.template(htmlInternalTemplate(options.eol))({ modulename: moduleName, varname: varName, content: htmlContent
 });
    }
    else {
        fileContent = _.template(replaceNewLines(options.htmlOutputTemplate, options.eol))({ modulename: moduleName, varname: varName
, content: htmlContent });
    }
    // Write the content to a file
    var outputfile = getOutputFile(filename, options.htmlOutDir, options.flatten);
    mkdirParent(path.dirname(outputfile));
    fs.writeFileSync(outputfile, fileContent);
    return outputfile;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        varFunction: _.template(options.htmlVarTemplate),
        htmlOutputTemplate: options.htmlOutputTemplate,
        htmlOutDir: options.htmlOutDir,
        flatten: options.htmlOutDirFlatten,
        eol: (options.newLine || utils.eol)
    };
    var htmlFiles = grunt.file.expand(options.html);
    generatedFiles = _.map(htmlFiles, function (filename) { return html2tsModule.<span class="apidocCodeKeywordSpan">compileHTML
</span>(filename, html2tsOptions_1); });
    generatedFiles.forEach(function (fileName) {
        if (filesToCompile.indexOf(fileName) === -1 &amp;&amp;
            grunt.file.isMatch(currentFiles.glob, fileName)) {
            filesToCompile.push(fileName);
        }
    });
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.optionsResolver" id="apidoc.module.grunt-ts.optionsResolver">module grunt-ts.optionsResolver</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.optionsResolver.resolveAsync" id="apidoc.element.grunt-ts.optionsResolver.resolveAsync">
        function <span class="apidocSignatureSpan">grunt-ts.optionsResolver.</span>resolveAsync
        <span class="apidocSignatureSpan">(rawTaskOptions, rawTargetOptions, targetName, resolvedFiles, theTemplateProcessor, theGlobExpander)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveAsync(rawTaskOptions, rawTargetOptions, targetName, resolvedFiles, theTemplateProcessor, theGlobExpander) {
    if (targetName === void 0) { targetName = ''; }
    if (resolvedFiles === void 0) { resolvedFiles = []; }
    if (theTemplateProcessor === void 0) { theTemplateProcessor = null; }
    if (theGlobExpander === void 0) { theGlobExpander = null; }
    var result = emptyOptionsResolveResult();
    return new es6_promise_1.Promise(function (resolve, reject) {
        if (theTemplateProcessor &amp;&amp; typeof theTemplateProcessor === 'function') {
            templateProcessor = theTemplateProcessor;
        }
        else {
            templateProcessor = noopTemplateProcessor;
        }
        if (theGlobExpander &amp;&amp; typeof theGlobExpander === 'function') {
            globExpander = theGlobExpander;
        }
        else {
            globExpander = emptyGlobExpander;
        }
        fixMissingOptions(rawTaskOptions);
        fixMissingOptions(rawTargetOptions);
        {
            var _a = resolveAndWarnOnConfigurationIssues(rawTaskOptions, rawTargetOptions, targetName), errors = _a.errors, warnings
 = _a.warnings;
            (_b = result.errors).push.apply(_b, errors);
            (_c = result.warnings).push.apply(_c, warnings);
        }
        result = applyGruntOptions(result, rawTaskOptions);
        result = applyGruntOptions(result, rawTargetOptions);
        result = copyCompilationTasks(result, resolvedFiles, resolveOutputOptions(rawTaskOptions, rawTargetOptions));
        visualStudioOptionsResolver_1.resolveVSOptionsAsync(result, rawTaskOptions, rawTargetOptions, templateProcessor).then(function
 (result) {
            tsconfig_1.resolveAsync(result, rawTaskOptions, rawTargetOptions, templateProcessor, globExpander).then(function (result
) {
                result = addressAssociatedOptionsAndResolveConflicts(result);
                result = enclosePathsInQuotesIfRequired(result);
                result = logAdditionalConfigurationWarnings(result);
                result = applyGruntTSDefaults(result);
                if (result.targetName === undefined ||
                    (!result.targetName &amp;&amp; targetName)) {
                    result.targetName = targetName;
                }
                return resolve(result);
            }).catch(function (tsConfigError) {
                result.errors.push('tsconfig error: ' + JSON.stringify(tsConfigError));
                return resolve(result);
            });
        }).catch(function (vsConfigError) {
            result.errors.push('Visual Studio config issue: ' + JSON.stringify(vsConfigError));
            return resolve(result);
        });
        var _b, _c;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentGruntTask = this;
var resolvedFiles = currentGruntTask.files;
// make async
done = currentGruntTask.async();
// get unprocessed templates from configuration
var rawTaskConfig = (grunt.config.getRaw(currentGruntTask.name) || {});
var rawTargetConfig = (grunt.config.getRaw(currentGruntTask.name + '.' + currentGruntTask.target) || {});
optionsResolver.<span class="apidocCodeKeywordSpan">resolveAsync</span>(rawTaskConfig, rawTargetConfig, currentGruntTask.target,
resolvedFiles, grunt.template.process, grunt.file.expand).then(function (result) {
    options = result;
    options.warnings.forEach(function (warning) {
        grunt.log.writeln(warning.magenta);
    });
    options.errors.forEach(function (error) {
        grunt.log.writeln(error.red);
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.reference" id="apidoc.module.grunt-ts.reference">module grunt-ts.reference</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.reference.updateReferenceFile" id="apidoc.element.grunt-ts.reference.updateReferenceFile">
        function <span class="apidocSignatureSpan">grunt-ts.reference.</span>updateReferenceFile
        <span class="apidocSignatureSpan">(files, generatedFiles, referenceFile, referencePath, eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateReferenceFile(files, generatedFiles, referenceFile, referencePath, eol) {
    var referenceIntro = '/// &lt;reference path="';
    var referenceEnd = '" /&gt;';
    var referenceMatch = /\/\/\/ &lt;reference path=\"(.*?)\"/;
    var ourSignatureStart = '//grunt-start';
    var ourSignatureEnd = '//grunt-end';
    // remove the generated files from files:
    files = _.difference(files, generatedFiles);
    var lines = []; // All lines of the file
    var origFileLines = []; // The lines we do not modify and send out as is. Lines will we reach grunt-ts generated
    var origFileReferences = []; // The list of files already there that we do not need to manage
    // Location of our generated references
    // By default at start of file
    var signatureSectionPosition = 0;
    var i;
    // Read the original file if it exists
    var referenceContents = '';
    if (fs.existsSync(referenceFile)) {
        referenceContents = fs.readFileSync(referenceFile).toString();
        lines = referenceContents.split(/\r\n|\r|\n/);
        var inSignatureSection = false;
        // By default our signature goes at end of file
        signatureSectionPosition = lines.length;
        for (i = 0; i &lt; lines.length; i++) {
            var line = _str.trim(lines[i]);
            // Skip logic for our generated section
            if (_str.include(line, ourSignatureStart)) {
                // Wait for the end signature:
                signatureSectionPosition = i;
                inSignatureSection = true;
                continue;
            }
            if (_str.include(line, ourSignatureEnd)) {
                inSignatureSection = false;
                continue;
            }
            if (inSignatureSection) {
                continue;
            }
            // store the line
            origFileLines.push(line);
            // Fetch the existing reference's filename if any:
            if (_str.include(line, referenceIntro)) {
                var match = line.match(referenceMatch);
                var filename = match[1];
                origFileReferences.push(filename);
            }
        }
    }
    // Put in the generated files
    generatedFiles = _.map(generatedFiles, function (file) { return referenceIntro + utils.makeRelativePath(referencePath, file) +
referenceEnd; });
    var contents = utils.insertArrayAt([ourSignatureStart], 1, generatedFiles);
    // Put in the new / observed missing files:
    files.forEach(function (filename) {
        // The file we are about to add
        var filepath = utils.makeRelativePath(referencePath, filename);
        // If there are orig references
        if (origFileReferences.length) {
            if (_.contains(origFileReferences, filepath)) {
                return;
            }
        }
        // Finally add the filepath
        contents.push(referenceIntro + filepath + referenceEnd);
    });
    contents.push(ourSignatureEnd);
    var updatedFileLines = utils.insertArrayAt(origFileLines, signatureSectionPosition, contents);
    var updatedFileContents = updatedFileLines.join(eol);
    // Modify the orig contents to put in our contents only if changed
    // Also Return whether the file was changed
    if (updatedFileContents !== referenceContents) {
        grunt.file.write(referenceFile, updatedFileContents);
        return true;
    }
    else {
        return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
///// Reference File
// Generate the reference file
// Create a reference file if specified
if (!!referencePath) {
    var result = timeIt(function () {
        return referenceModule.<span class="apidocCodeKeywordSpan">updateReferenceFile</span>(filesToCompile.filter(function (f) {
return !isReferenceFile(f); }), generatedFiles, referenceFile, referencePath, (options.newLine || utils.eol));
    });
    if (result.it === true) {
        grunt.log.writeln(('Updated reference file (' + result.time + 'ms).').green);
    }
}
///// AMD loader
// Create the amdLoader if specified
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.templateCache" id="apidoc.module.grunt-ts.templateCache">module grunt-ts.templateCache</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.templateCache.generateTemplateCache" id="apidoc.element.grunt-ts.templateCache.generateTemplateCache">
        function <span class="apidocSignatureSpan">grunt-ts.templateCache.</span>generateTemplateCache
        <span class="apidocSignatureSpan">(src, dest, basePath, eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateTemplateCache(src, dest, basePath, eol) {
    if (!src.length) {
        return;
    }
    // Resolve the relative path from basePath to each src file
    var relativePaths = _.map(src, function (anHtmlFile) { return 'text!' + utils.makeRelativePath(basePath, anHtmlFile); });
    var fileNames = _.map(src, function (anHtmlFile) { return path.basename(anHtmlFile); });
    var fileVarialbeName = function (anHtmlFile) { return anHtmlFile.split('.').join('_').split('-').join('_'); };
    var fileVariableNames = _.map(fileNames, fileVarialbeName);
    var templateCacheTemplate = _.template('// You must have requirejs + text plugin loaded for this to work.'
        + eol + 'define([&lt;%=relativePathSection%&gt;],function(&lt;%=fileNameVariableSection%&gt;){'
        + eol + 'angular.module("ng").run(["$templateCache",function($templateCache) {'
        + eol + '&lt;%=templateCachePut%&gt;'
        + eol + '}]);'
        + eol + '});');
    var relativePathSection = '"' + relativePaths.join('",' + eol + '"') + '"';
    var fileNameVariableSection = fileVariableNames.join(',' + eol);
    var templateCachePutTemplate = _.template('$templateCache.put("&lt;%= fileName %&gt;", &lt;%=fileVariableName%&gt;);');
    var templateCachePut = _.map(fileNames, function (fileName) { return templateCachePutTemplate({
        fileName: fileName,
        fileVariableName: fileVarialbeName(fileName)
    }); }).join(eol);
    var fileContent = templateCacheTemplate({
        relativePathSection: relativePathSection,
        fileNameVariableSection: fileNameVariableSection,
        templateCachePut: templateCachePut
    });
    // Early exit if new templateCache doesn't change
    if (fs.existsSync(dest)) {
        var originalContents = fs.readFileSync(dest).toString();
        if (originalContents === fileContent) {
            return;
        }
    }
    // write updated contents
    fs.writeFileSync(dest, fileContent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!options.templateCache.src || !options.templateCache.dest || !options.templateCache.baseUrl) {
        grunt.log.writeln('templateCache : src, dest, baseUrl must be specified if templateCache option is used'.red);
    }
    else {
        var templateCacheSrc = grunt.file.expand(options.templateCache.src); // manual reinterpolation
        var templateCacheDest = path.resolve(options.templateCache.dest);
        var templateCacheBasePath = path.resolve(options.templateCache.baseUrl);
        templateCacheModule.<span class="apidocCodeKeywordSpan">generateTemplateCache</span>(templateCacheSrc, templateCacheDest
, templateCacheBasePath, (options.newLine || utils.eol));
    }
}
///// Reference File
// Generate the reference file
// Create a reference file if specified
if (!!referencePath) {
    var result = timeIt(function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.transformers" id="apidoc.module.grunt-ts.transformers">module grunt-ts.transformers</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.transformers.transformFiles" id="apidoc.element.grunt-ts.transformers.transformFiles">
        function <span class="apidocSignatureSpan">grunt-ts.transformers.</span>transformFiles
        <span class="apidocSignatureSpan">(changedFiles, targetFiles, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformFiles(changedFiles, targetFiles, options) {
    currentTargetDirs = getTargetFolders(targetFiles);
    currentTargetFiles = targetFiles;
    ///////////////////////////////////// transformation
    var transformers = [
        new ImportTransformer(),
        new ExportTransformer((options.newLine || utils.eol)),
        new ReferenceTransformer(),
        new UnknownTransformer()
    ];
    _.forEach(changedFiles, function (fileToProcess) {
        var contents = fs.readFileSync(fileToProcess).toString().replace(/^\uFEFF/, '');
        // If no signature don't bother with this file
        if (!BaseTransformer.containsTransformSignature(contents)) {
            return;
        }
        var lines = contents.split(/\r\n|\r|\n/);
        var outputLines = [];
        for (var i = 0; i &lt; lines.length; i++) {
            var line = lines[i];
            //// Debugging
            // grunt.log.writeln('line'.green);
            // grunt.log.writeln(line);
            // Skip generated lines as these will get regenerated
            if (_.some(transformers, function (transformer) { return transformer.isGenerated(line); })) {
                continue;
            }
            // Directive line
            if (_.some(transformers, function (transformer) {
                var match = transformer.matches(line);
                if (match) {
                    // The code gen directive line automatically qualifies
                    outputLines.push(line);
                    // pass transform settings to transform (match[1] is the equals sign, ensure it exists but otherwise ignore
it)
                    outputLines.push.apply(outputLines, transformer.transform(fileToProcess, match[1] &amp;&amp; match[2] &amp;&amp; match[2].trim
()));
                    return true;
                }
                return false;
            })) {
                continue;
            }
            // Lines not generated or not directives
            outputLines.push(line);
        }
        var transformedContent = outputLines.join(utils.eol);
        if (transformedContent !== contents) {
            grunt.file.write(fileToProcess, transformedContent);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
///// AMD loader
// Create the amdLoader if specified
if (!!amdloaderPath) {
    var referenceOrder = amdLoaderModule.getReferencesInOrder(referenceFile, referencePath, generatedFiles);
    amdLoaderModule.updateAmdLoader(referenceFile, referenceOrder, amdloaderFile, amdloaderPath, currentFiles.outDir);
}
// Transform files as needed. Currently all of this logic in is one module
transformers.<span class="apidocCodeKeywordSpan">transformFiles</span>(filesToCompile /*TODO: only unchanged files*/, filesToCompile
, options);
currentFiles.src = filesToCompile;
// Return promise to compliation
if (utils.shouldCompile(options)) {
    if (filesToCompile.length &gt; 0 || options.testExecute || utils.shouldPassThrough(options)) {
        return runCompilation(options, currentFiles).then(function (success) {
            return success;
        });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.tsconfig" id="apidoc.module.grunt-ts.tsconfig">module grunt-ts.tsconfig</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.tsconfig.resolveAsync" id="apidoc.element.grunt-ts.tsconfig.resolveAsync">
        function <span class="apidocSignatureSpan">grunt-ts.tsconfig.</span>resolveAsync
        <span class="apidocSignatureSpan">(applyTo, taskOptions, targetOptions, theTemplateProcessor, theGlobExpander)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveAsync(applyTo, taskOptions, targetOptions, theTemplateProcessor, theGlobExpander) {
    if (theGlobExpander === void 0) { theGlobExpander = null; }
    templateProcessor = theTemplateProcessor;
    globExpander = theGlobExpander;
    gruntfileGlobs = getGlobs(taskOptions, targetOptions);
    return new es6_promise_1.Promise(function (resolve, reject) {
        try {
            var taskTSConfig = getTSConfigSettings(taskOptions);
            var targetTSConfig = getTSConfigSettings(targetOptions);
            var tsconfig = null;
            if (taskTSConfig) {
                tsconfig = taskTSConfig;
            }
            if (targetTSConfig) {
                if (!tsconfig) {
                    tsconfig = targetTSConfig;
                }
                if ('tsconfig' in targetTSConfig) {
                    tsconfig.tsconfig = templateProcessor(targetTSConfig.tsconfig, {});
                }
                if ('ignoreSettings' in targetTSConfig) {
                    tsconfig.ignoreSettings = targetTSConfig.ignoreSettings;
                }
                if ('overwriteFilesGlob' in targetTSConfig) {
                    tsconfig.overwriteFilesGlob = targetTSConfig.overwriteFilesGlob;
                }
                if ('updateFiles' in targetTSConfig) {
                    tsconfig.updateFiles = targetTSConfig.updateFiles;
                }
                if ('passThrough' in targetTSConfig) {
                    tsconfig.passThrough = targetTSConfig.passThrough;
                }
            }
            applyTo.tsconfig = tsconfig;
        }
        catch (ex) {
            return reject(ex);
        }
        if (!applyTo.tsconfig) {
            return resolve(applyTo);
        }
        if (applyTo.tsconfig.passThrough) {
            if (applyTo.CompilationTasks.length === 0) {
                applyTo.CompilationTasks.push({ src: [] });
            }
            if (!applyTo.tsconfig.tsconfig) {
                applyTo.tsconfig.tsconfig = '.';
            }
        }
        else {
            var projectFile = applyTo.tsconfig.tsconfig;
            try {
                var projectFileTextContent = fs.readFileSync(projectFile, 'utf8');
            }
            catch (ex) {
                if (ex &amp;&amp; ex.code === 'ENOENT') {
                    return reject('Could not find file "' + projectFile + '".');
                }
                else if (ex &amp;&amp; ex.errno) {
                    return reject('Error ' + ex.errno + ' reading "' + projectFile + '".');
                }
                else {
                    return reject('Error reading "' + projectFile + '": ' + JSON.stringify(ex));
                }
            }
            try {
                var projectSpec;
                var content = stripBom(projectFileTextContent);
                if (content.trim() === '') {
                    projectSpec = {};
                }
                else {
                    projectSpec = JSON.parse(content);
                }
            }
            catch (ex) {
                return reject('Error parsing "' + projectFile + '".  It may not be valid JSON in UTF-8.');
            }
            applyTo = warnOnBadConfiguration(applyTo, projectSpec);
            applyTo = applyCompilerOptions(applyTo, projectSpec);
            applyTo = resolve_output_locations(applyTo, projectSpec);
        }
        resolve(applyTo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentGruntTask = this;
var resolvedFiles = currentGruntTask.files;
// make async
done = currentGruntTask.async();
// get unprocessed templates from configuration
var rawTaskConfig = (grunt.config.getRaw(currentGruntTask.name) || {});
var rawTargetConfig = (grunt.config.getRaw(currentGruntTask.name + '.' + currentGruntTask.target) || {});
optionsResolver.<span class="apidocCodeKeywordSpan">resolveAsync</span>(rawTaskConfig, rawTargetConfig, currentGruntTask.target,
resolvedFiles, grunt.template.process, grunt.file.expand).then(function (result) {
    options = result;
    options.warnings.forEach(function (warning) {
        grunt.log.writeln(warning.magenta);
    });
    options.errors.forEach(function (error) {
        grunt.log.writeln(error.red);
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.utils" id="apidoc.module.grunt-ts.utils">module grunt-ts.utils</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.utils.asyncSeries" id="apidoc.element.grunt-ts.utils.asyncSeries">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>asyncSeries
        <span class="apidocSignatureSpan">(items, callPerItem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncSeries(items, callPerItem) {
    items = items.slice(0);
    var memo = [];
    // Run one at a time
    return new es6_promise_1.Promise(function (resolve, reject) {
        var next = function () {
            if (items.length === 0) {
                resolve(memo);
                return;
            }
            es6_promise_1.Promise
                .cast(callPerItem(items.shift()))
                .then(function (result) {
                memo.push(result);
                next();
            }, reject);
        };
        next();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.copyFile" id="apidoc.element.grunt-ts.utils.copyFile">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>copyFile
        <span class="apidocSignatureSpan">(srcFile, destFile, callback, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyFile(srcFile, destFile, callback, encoding) {
    if (encoding === void 0) { encoding = 'utf8'; }
    fs.readFile(srcFile, encoding, function (err, data) {
        fs.writeFile(destFile, data, encoding, function (err) {
            if (err) {
                return callback(err);
            }
            return callback();
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.enclosePathInQuotesIfRequired" id="apidoc.element.grunt-ts.utils.enclosePathInQuotesIfRequired">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>enclosePathInQuotesIfRequired
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enclosePathInQuotesIfRequired(path) {
    if (!path || !path.indexOf) {
        return path;
    }
    if (path.indexOf(' ') === -1) {
        return path;
    }
    else {
        var newPath = path.trim();
        if (newPath.indexOf('"') === 0 &amp;&amp; newPath.lastIndexOf('"') === newPath.length - 1) {
            return newPath;
        }
        else {
            return '"' + newPath + '"';
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0; i &lt; resolvedFiles.length; i += 1) {
var glob = void 0;
var orig = resolvedFiles[i].orig;
if (orig &amp;&amp; ('src' in orig)) {
    glob = [].concat(orig.src);
}
var compilationSet = {
    src: _.map(resolvedFiles[i].src, function (fileName) { return utils.<span class="apidocCodeKeywordSpan">enclosePathInQuotesIfRequired
</span>(fileName); }),
    out: utils.enclosePathInQuotesIfRequired(resolvedFiles[i].out),
    outDir: utils.enclosePathInQuotesIfRequired(resolvedFiles[i].outDir),
    glob: glob
};
if ('dest' in resolvedFiles[i] &amp;&amp; resolvedFiles[i].dest) {
    var dest = void 0;
    if (_.isArray(resolvedFiles[i].dest)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.endsWith" id="apidoc.element.grunt-ts.utils.endsWith">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>endsWith
        <span class="apidocSignatureSpan">(str, suffix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endsWith(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
lastCompile = new Date().getTime();
// Run initial compile
return filterFilesTransformAndCompile();
// local event to handle file event
function handleFileEvent(filepath, displaystr, addedOrChanged) {
    if (addedOrChanged === void 0) { addedOrChanged = false; }
    // Only ts and html :
    if (!utils.<span class="apidocCodeKeywordSpan">endsWith</span>(filepath.toLowerCase(), '.ts') &amp;&amp; !utils.
endsWith(filepath.toLowerCase(), '.html')) {
        return;
    }
    // Do not run if just ran, behaviour same as grunt-watch
    // These are the files our run modified
    if ((new Date().getTime() - lastCompile) &lt;= 100) {
        // Uncomment for debugging which files were ignored
        // grunt.log.writeln((' ///'  + ' &gt;&gt;' + filepath).grey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.findCommonPath" id="apidoc.element.grunt-ts.utils.findCommonPath">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>findCommonPath
        <span class="apidocSignatureSpan">(paths, pathSeperator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findCommonPath(paths, pathSeperator) {
    // Now for "C:\u\starter" "C:\u\started" =&gt; "C:\u\starte"
    var largetStartSegement = sharedStart(paths);
    // For "C:\u\starte" =&gt; C:\u\
    var ending = largetStartSegement.lastIndexOf(pathSeperator);
    return largetStartSegement.substr(0, ending);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return path.resolve(filename) === outFile_d_ts;
}
// see https://github.com/grunt-ts/grunt-ts/issues/77
function isBaseDirFile(filename, targetFiles) {
    var baseDirFile = '.baseDir.ts';
    var bd = '';
    if (!options.baseDir) {
        bd = utils.<span class="apidocCodeKeywordSpan">findCommonPath</span>(targetFiles, '/');
        options.baseDir = bd;
    }
    return path.resolve(filename) === path.resolve(path.join(bd, baseDirFile));
}
// Create an amd loader?
var amdloader = options.amdloader;
var amdloaderFile, amdloaderPath;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.firstElementWithValue" id="apidoc.element.grunt-ts.utils.firstElementWithValue">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>firstElementWithValue
        <span class="apidocSignatureSpan">(elements, defaultResult)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function firstElementWithValue(elements, defaultResult) {
    if (defaultResult === void 0) { defaultResult = null; }
    var result = defaultResult;
    _.each(elements, function (item) {
        if (hasValue(item)) {
            result = item;
            return false; // break out of lodash loop
        }
        return undefined;
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.format" id="apidoc.element.grunt-ts.utils.format">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>format
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function format(str) {
    var args = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return str.replace(/{(\d+)}/g, function (m, i) {
        return args[i] !== undefined ? args[i] : m;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
});
return Object.keys(folders);
}
var BaseTransformer = (function () {
function BaseTransformer(key, variableSyntax) {
    this.key = key;
    this.match = new RegExp(utils.<span class="apidocCodeKeywordSpan">format</span>(BaseTransformer.tsTransformerMatch, key));
    this.signature = this.tripleSlashTS() + key;
    this.signatureGenerated = this.signature + ':generated';
    this.syntaxError = '/// Invalid syntax for ts:' + this.key + '=' + variableSyntax + ' ' + this
.signatureGenerated;
}
BaseTransformer.prototype.tripleSlashTS = function () {
    // This is a function and broken into two strings to prevent the transformers module from
    // transforming *itself* (a-la Skynet).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getDirs" id="apidoc.element.grunt-ts.utils.getDirs">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getDirs
        <span class="apidocSignatureSpan">(dirPath, exclude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDirs(dirPath, exclude) {
    return _getAll(dirPath, exclude, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getFiles" id="apidoc.element.grunt-ts.utils.getFiles">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getFiles
        <span class="apidocSignatureSpan">(dirPath, exclude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFiles(dirPath, exclude) {
    return _getAll(dirPath, exclude, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// use index.ts instead of all the files in the directory
if (getIndexIfDir
    &amp;&amp; fs.existsSync(possibleIndexFilePath)
    &amp;&amp; path.relative(currentFilePath, possibleIndexFilePath) !== '') {
    files.push(path.join(targetDir, 'index.ts'));
}
else {
    var filesInDir = utils.<span class="apidocCodeKeywordSpan">getFiles</span>(targetDir, function (filename) {
        // exclude current file
        if (path.relative(currentFilePath, filename) === '') {
            return true;
        }
        return path.extname(filename) // must have extension : do not exclude directories
            &amp;&amp; (!_str.endsWith(filename, '.ts') || _str.endsWith(filename, '.d.ts'))
            &amp;&amp; !fs.lstatSync(filename).isDirectory(); // for people that name directories with dots
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getOrGetFirst" id="apidoc.element.grunt-ts.utils.getOrGetFirst">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getOrGetFirst
        <span class="apidocSignatureSpan">(getFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOrGetFirst(getFrom) {
    if (_.isArray(getFrom)) {
        if (getFrom.length &gt; 0) {
            return getFrom[0];
        }
        return '';
    }
    return getFrom;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getRandomHex" id="apidoc.element.grunt-ts.utils.getRandomHex">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getRandomHex
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomHex(length) {
    if (length === void 0) { length = 16; }
    var name = '';
    do {
        name += Math.round(Math.random() * Math.pow(16, 8)).toString(16);
    } while (name.length &lt; length);
    return name.substr(0, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.getTempFile" id="apidoc.element.grunt-ts.utils.getTempFile">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>getTempFile
        <span class="apidocSignatureSpan">(prefix, dir, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTempFile(prefix, dir, extension) {
    if (dir === void 0) { dir = ''; }
    if (extension === void 0) { extension = '.tmp.txt'; }
    prefix = (prefix ? prefix + '-' : '');
    var attempts = 100;
    do {
        var name = prefix + getRandomHex(8) + extension;
        var dest = path.join(dir, name);
        if (!fs.existsSync(dest)) {
            return dest;
        }
        attempts--;
    } while (attempts &gt; 0);
    throw 'Cannot create temp file in ' + dir;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.log(args.join(' ').yellow);
}
else {
    exports.grunt.log.verbose.writeln(args.join(' ').yellow);
}
// Create a temp last command file and use that to guide tsc.
// Reason: passing all the files on the command line causes TSC to go in an infinite loop.
var tempfilename = utils.<span class="apidocCodeKeywordSpan">getTempFile</span>('tscommand');
if (!tempfilename) {
    throw (new Error('cannot create temp file'));
}
fs.writeFileSync(tempfilename, args.join(' '));
var command;
// Switch implementation if a test version of executeNode exists.
if ('testExecute' in options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.hasValue" id="apidoc.element.grunt-ts.utils.hasValue">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>hasValue
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasValue(thing) {
    return !_.isNull(thing) &amp;&amp; !_.isUndefined(thing);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}
function applyGruntOptions(applyTo, gruntOptions) {
if (gruntOptions) {
    for (var _i = 0, propertiesFromTarget_1 = propertiesFromTarget; _i &lt; propertiesFromTarget_1.length; _i++) {
        var propertyName = propertiesFromTarget_1[_i];
        if (propertyName in gruntOptions &amp;&amp; propertyName !== 'vs') {
            if (typeof gruntOptions[propertyName] === 'string' &amp;&amp; utils.<span class="apidocCodeKeywordSpan">
hasValue</span>(gruntOptions[propertyName]) &amp;&amp;
                delayTemplateExpansion.indexOf(propertyName) === -1) {
                applyTo[propertyName] = templateProcessor(gruntOptions[propertyName], {});
            }
            else {
                applyTo[propertyName] = gruntOptions[propertyName];
            }
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.insertArrayAt" id="apidoc.element.grunt-ts.utils.insertArrayAt">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>insertArrayAt
        <span class="apidocSignatureSpan">(array, index, arrayToInsert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertArrayAt(array, index, arrayToInsert) {
    var updated = array.slice(0);
    var spliceAt = [index, 0];
    Array.prototype.splice.apply(updated, spliceAt.concat(arrayToInsert));
    return updated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            var filename = match[1];
            origFileReferences.push(filename);
        }
    }
}
// Put in the generated files
generatedFiles = _.map(generatedFiles, function (file) { return referenceIntro + utils.makeRelativePath(referencePath, file) + referenceEnd
; });
var contents = utils.<span class="apidocCodeKeywordSpan">insertArrayAt</span>([ourSignatureStart], 1, generatedFiles);
// Put in the new / observed missing files:
files.forEach(function (filename) {
    // The file we are about to add
    var filepath = utils.makeRelativePath(referencePath, filename);
    // If there are orig references
    if (origFileReferences.length) {
        if (_.contains(origFileReferences, filepath)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.isJavaScriptFile" id="apidoc.element.grunt-ts.utils.isJavaScriptFile">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>isJavaScriptFile
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJavaScriptFile(filePath) {
    if (filePath.toLowerCase) {
        var normalizedFile = path.resolve(stripQuotesIfQuoted(filePath)).toLowerCase();
        return endsWith(normalizedFile, '.js');
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (compilationInfo.out) {
    // We only pass --out instead of --outFile for backward-compatability reasons.
    // It is the same for purposes of the command-line (the subtle difference is handled in the tsconfig code
    //  and the value of --outFile is copied to --out).
    args.push('--out', compilationInfo.out);
}
if (compilationInfo.dest &amp;&amp; (!compilationInfo.out) &amp;&amp; (!compilationInfo.outDir)) {
    if (utils.<span class="apidocCodeKeywordSpan">isJavaScriptFile</span>(compilationInfo.dest)) {
        args.push('--out', compilationInfo.dest);
    }
    else {
        if (compilationInfo.dest === 'src') {
            console.warn(('WARNING: Destination for target "' + options.targetName + '" is "src"
;, which is the default.  If you have' +
                ' forgotten to specify a "dest" parameter, please add it.  If this is correct, you may wish' +
                ' to change the "dest" parameter to "src/" or just ignore this warning.').magenta);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.makeRelativePath" id="apidoc.element.grunt-ts.utils.makeRelativePath">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>makeRelativePath
        <span class="apidocSignatureSpan">(folderpath, filename, forceRelative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeRelativePath(folderpath, filename, forceRelative) {
    if (forceRelative === void 0) { forceRelative = false; }
    var relativePath = path.relative(folderpath, filename).split('\\').join('/');
    if (forceRelative &amp;&amp; relativePath[0] !== '.') {
        relativePath = './' + relativePath;
    }
    return relativePath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var makeRelativeToOutDir = function (files) {
    files = _.map(files, function (file) {
        // Remove common path and replace with absolute outDir
        file = file.replace(commonPath, outDir);
        // remove extension '.ts' / '.tsx':
        file = file.substr(0, file.lastIndexOf('.'));
        // Make relative to amd loader
        file = utils.<span class="apidocCodeKeywordSpan">makeRelativePath</span>(loaderPath, file);
        // Prepend "./" to prevent "basePath" requirejs setting from interferring:
        file = './' + file;
        return file;
    });
    return files;
};
// Read the original file if it exists
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.newLineActualAsParameter" id="apidoc.element.grunt-ts.utils.newLineActualAsParameter">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineActualAsParameter
        <span class="apidocSignatureSpan">(actualNewLineChars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newLineActualAsParameter(actualNewLineChars) {
    if (actualNewLineChars) {
        return actualNewLineChars.replace(/\n/g, 'LF').replace(/\r/g, 'CR');
    }
    return '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.newLineIsRedundantForTsc" id="apidoc.element.grunt-ts.utils.newLineIsRedundantForTsc">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineIsRedundantForTsc
        <span class="apidocSignatureSpan">(newLineParameter, operatingSystem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newLineIsRedundantForTsc(newLineParameter, operatingSystem) {
    if (operatingSystem === void 0) { operatingSystem = os; }
    return ((newLineParameter === 'CRLF' &amp;&amp; operatingSystem.EOL === '\r\n') ||
        (newLineParameter === 'LF' &amp;&amp; operatingSystem.EOL === '\n'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (options.inlineSources) {
    args.push('--inlineSources');
}
if (options.inlineSourceMap) {
    args.push('--inlineSourceMap');
}
if (options.newLine &amp;&amp; !utils.<span class="apidocCodeKeywordSpan">newLineIsRedundantForTsc</span>(options.newLine)) {
    args.push('--newLine', options.newLine);
}
if (options.isolatedModules) {
    args.push('--isolatedModules');
}
if (options.noEmitHelpers) {
    args.push('--noEmitHelpers');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.newLineParameterAsActual" id="apidoc.element.grunt-ts.utils.newLineParameterAsActual">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>newLineParameterAsActual
        <span class="apidocSignatureSpan">(parameterNewLineChars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newLineParameterAsActual(parameterNewLineChars) {
    if (parameterNewLineChars) {
        return parameterNewLineChars.replace(/LF/g, '\n').replace(/CR/g, '\r');
    }
    return '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.readAndParseJSONFromFileSync" id="apidoc.element.grunt-ts.utils.readAndParseJSONFromFileSync">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>readAndParseJSONFromFileSync
        <span class="apidocSignatureSpan">(fileName, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readAndParseJSONFromFileSync(fileName, encoding) {
    if (encoding === void 0) { encoding = 'utf8'; }
    var textContent, result;
    try {
        textContent = fs.readFileSync(fileName, encoding);
    }
    catch (ex) {
        throw new Error("Error reading file " + fileName + ": " + ex);
    }
    try {
        result = JSON.parse(textContent);
    }
    catch (ex) {
        throw new Error("Error parsing JSON in file " + fileName + ": " + ex);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0; i &lt; filesRelativeToGruntfile.length; i += 1) {
        filesRelativeToGruntfile[i] = filesRelativeToGruntfile[i].replace(/\\/g, '/');
        filesRelativeToTSConfig_temp.push(path.relative(relativePathFromGruntfileToTSConfig_1, filesRelativeToGruntfile[i]).replace
(/\\/g, '/'));
    }
    filesRelativeToTSConfig.length = 0;
    filesRelativeToTSConfig.push.apply(filesRelativeToTSConfig, filesRelativeToTSConfig_temp);
}
var tsconfigJSONContent = utils.<span class="apidocCodeKeywordSpan">readAndParseJSONFromFileSync</span>(tsconfigFileName);
var tempTSConfigFiles = tsconfigJSONContent.files || [];
if (_.difference(tempTSConfigFiles, filesRelativeToTSConfig).length &gt; 0 ||
    _.difference(filesRelativeToTSConfig, tempTSConfigFiles).length &gt; 0) {
    try {
        tsconfigJSONContent.files = filesRelativeToTSConfig;
        saveTSConfigSync(tsconfigFileName, tsconfigJSONContent);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.shouldCompile" id="apidoc.element.grunt-ts.utils.shouldCompile">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>shouldCompile
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldCompile(options) {
    return !!options.compile;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var referenceOrder = amdLoaderModule.getReferencesInOrder(referenceFile, referencePath, generatedFiles);
    amdLoaderModule.updateAmdLoader(referenceFile, referenceOrder, amdloaderFile, amdloaderPath, currentFiles.outDir);
}
// Transform files as needed. Currently all of this logic in is one module
transformers.transformFiles(filesToCompile /*TODO: only unchanged files*/, filesToCompile, options);
currentFiles.src = filesToCompile;
// Return promise to compliation
if (utils.<span class="apidocCodeKeywordSpan">shouldCompile</span>(options)) {
    if (filesToCompile.length &gt; 0 || options.testExecute || utils.shouldPassThrough(options)) {
        return runCompilation(options, currentFiles).then(function (success) {
            return success;
        });
    }
    else {
        // Nothing to do
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.shouldPassThrough" id="apidoc.element.grunt-ts.utils.shouldPassThrough">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>shouldPassThrough
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldPassThrough(options) {
    return (options.tsconfig &amp;&amp; options.tsconfig.passThrough);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isSuccessfulBuild = (!isError ||
    (isError &amp;&amp; isOnlyTypeErrors &amp;&amp; !options.failOnTypeErrors));
if (isSuccessfulBuild) {
    // Report successful build.
    var time = (endtime - starttime) / 1000;
    grunt.log.writeln('');
    var message = 'TypeScript compilation complete: ' + time.toFixed(2) + 's';
    if (utils.<span class="apidocCodeKeywordSpan">shouldPassThrough</span>(options)) {
        message += ' for TypeScript pass-through.';
    }
    else {
        message += ' for ' + result.fileCount + ' TypeScript files.';
    }
    grunt.log.writeln(message.green);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.stripQuotesIfQuoted" id="apidoc.element.grunt-ts.utils.stripQuotesIfQuoted">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>stripQuotesIfQuoted
        <span class="apidocSignatureSpan">(possiblyQuotedString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stripQuotesIfQuoted(possiblyQuotedString) {
    if (!possiblyQuotedString.length || possiblyQuotedString.length &lt; 2) {
        return possiblyQuotedString;
    }
    if (possiblyQuotedString.charAt(0) === '"' &amp;&amp;
        possiblyQuotedString.charAt(possiblyQuotedString.length - 1) === '"') {
        return possiblyQuotedString.substr(1, possiblyQuotedString.length - 2);
    }
    return possiblyQuotedString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.grunt-ts.utils.timeIt" id="apidoc.element.grunt-ts.utils.timeIt">
        function <span class="apidocSignatureSpan">grunt-ts.utils.</span>timeIt
        <span class="apidocSignatureSpan">(makeIt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeIt(makeIt) {
    var starttime = new Date().getTime();
    var it = makeIt();
    var endtime = new Date().getTime();
    return {
        it: it,
        time: endtime - starttime
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-ts.visualStudioOptionsResolver" id="apidoc.module.grunt-ts.visualStudioOptionsResolver">module grunt-ts.visualStudioOptionsResolver</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-ts.visualStudioOptionsResolver.resolveVSOptionsAsync" id="apidoc.element.grunt-ts.visualStudioOptionsResolver.resolveVSOptionsAsync">
        function <span class="apidocSignatureSpan">grunt-ts.visualStudioOptionsResolver.</span>resolveVSOptionsAsync
        <span class="apidocSignatureSpan">(applyTo, taskOptions, targetOptions, theTemplateProcessor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveVSOptionsAsync(applyTo, taskOptions, targetOptions, theTemplateProcessor) {
    templateProcessor = theTemplateProcessor;
    return new es6_promise_1.Promise(function (resolve, reject) {
        {
            var vsTask = getVSSettings(taskOptions), vsTarget = getVSSettings(targetOptions);
            var vs = null;
            if (vsTask) {
                vs = vsTask;
            }
            if (vsTarget) {
                if (!vs) {
                    vs = vsTarget;
                }
                if (vsTarget.project) {
                    vs.project = vsTarget.project;
                }
                if (vsTarget.config) {
                    vs.config = vsTarget.config;
                }
                if (vsTarget.ignoreFiles) {
                    vs.ignoreFiles = vsTarget.ignoreFiles;
                }
                if (vsTarget.ignoreSettings) {
                    vs.ignoreSettings = vsTarget.ignoreSettings;
                }
            }
            if (vs) {
                applyTo.vs = vs;
                if (typeof applyTo.vs.project === 'string') {
                    applyTo.vs.project = templateProcessor(applyTo.vs.project, {});
                }
                if (typeof applyTo.vs.config === 'string') {
                    applyTo.vs.config = templateProcessor(applyTo.vs.config, {});
                }
            }
        }
        if (applyTo.vs) {
            return csproj2ts.getTypeScriptSettings({
                ProjectFileName: applyTo.vs.project,
                ActiveConfiguration: applyTo.vs.config || undefined
            }).then(function (vsConfig) {
                try {
                    applyTo = applyVSOptions(applyTo, vsConfig);
                    applyTo = resolve_out_and_outDir(applyTo, taskOptions, targetOptions);
                    return resolve(applyTo);
                }
                catch (ex) {
                    return reject(ex);
                }
            }).catch(function (error) {
                if (error.errno === 34) {
                    applyTo.errors.push('In target "' + applyTo.targetName + '" - could not find VS project at "' + error.path + '".');
                }
                else {
                    applyTo.errors.push('In target "' + applyTo.targetName + '".  Error #' + error.errno + '.  ' + error);
                }
                return reject(error);
            });
        }
        return resolve(applyTo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var _a = resolveAndWarnOnConfigurationIssues(rawTaskOptions, rawTargetOptions, targetName), errors = _a.errors, warnings = _a
.warnings;
    (_b = result.errors).push.apply(_b, errors);
    (_c = result.warnings).push.apply(_c, warnings);
}
result = applyGruntOptions(result, rawTaskOptions);
result = applyGruntOptions(result, rawTargetOptions);
result = copyCompilationTasks(result, resolvedFiles, resolveOutputOptions(rawTaskOptions, rawTargetOptions));
visualStudioOptionsResolver_1.<span class="apidocCodeKeywordSpan">resolveVSOptionsAsync</span>(result, rawTaskOptions, rawTargetOptions
, templateProcessor).then(function (result) {
    tsconfig_1.resolveAsync(result, rawTaskOptions, rawTargetOptions, templateProcessor, globExpander).then(function (result) {
        result = addressAssociatedOptionsAndResolveConflicts(result);
        result = enclosePathsInQuotesIfRequired(result);
        result = logAdditionalConfigurationWarnings(result);
        result = applyGruntTSDefaults(result);
        if (result.targetName === undefined ||
            (!result.targetName &amp;&amp; targetName)) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>